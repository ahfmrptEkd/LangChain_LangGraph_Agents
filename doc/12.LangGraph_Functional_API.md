# 🎯 LangGraph Functional API 완전 가이드

> 기존 코드에 최소한의 변경으로 LangGraph 기능을 통합하는 새로운 방식

## 📚 목차

- [Functional API 개요](#-functional-api-개요)
- [Graph API vs Functional API](#-graph-api-vs-functional-api)
- [핵심 구성 요소](#-핵심-구성-요소)
- [고급 기능](#-고급-기능)
- [실전 예제](#-실전-예제)
- [베스트 프랙티스](#-베스트-프랙티스)
- [주의사항](#-주의사항)
- [언제 사용할까?](#-언제-사용할까)
- [결론](#-결론)
- [참고 자료](#-참고-자료)

---

## 🎯 Functional API 개요

### 정의
**Functional API는 기존 코드에 최소한의 변경으로 LangGraph의 핵심 기능을 통합할 수 있는 새로운 접근 방식입니다.**

### 핵심 특징
- ✅ **최소 변경**: 기존 코드 구조 유지
- ✅ **표준 Python 구문**: `if`, `for`, 함수 호출 등 그대로 사용
- ✅ **자동 상태 관리**: 명시적 State 정의 불필요
- ✅ **선택적 도입**: 필요한 부분만 점진적 적용

### 제공하는 핵심 기능
- 🔄 **Persistence**: 자동 체크포인팅
- 🧠 **Memory**: 대화 히스토리 관리  
- 👤 **Human-in-the-loop**: 사용자 개입 지점
- 📡 **Streaming**: 실시간 결과 스트리밍

---

## 📊 Graph API vs Functional API

| 특성 | Graph API | Functional API |
|------|-----------|----------------|
| **제어 흐름** | 명시적 그래프 구조 | 표준 Python 구문 |
| **상태 관리** | State 클래스 정의 필요 | 자동 관리 (함수 스코프) |
| **코드 양** | 많음 (그래프 정의) | 적음 (데코레이터만) |
| **체크포인팅** | superstep마다 새로 생성 | 기존 체크포인트에 저장 |
| **시각화** | 지원 (그래프 뷰) | 미지원 (동적 생성) |
| **학습 곡선** | 가파름 | 완만함 |
| **적용 시기** | 새 프로젝트, 복잡한 워크플로우 | 기존 코드 개선, 빠른 프로토타입 |

### 코드 비교 예시

**Graph API 방식:**
```python
from langgraph.graph import StateGraph, MessagesState, START, END

def chat_node(state: MessagesState):
    response = llm.invoke(state["messages"])
    return {"messages": [response]}

# 그래프 구조 정의
workflow = StateGraph(MessagesState)
workflow.add_node("chat", chat_node)
workflow.add_edge(START, "chat")
workflow.add_edge("chat", END)

app = workflow.compile(checkpointer=checkpointer)
```

**Functional API 방식:**
```python
from langgraph.func import entrypoint

@entrypoint(checkpointer=checkpointer)
def workflow(query: str) -> str:
    response = llm.invoke(query)
    return response
```

---

## 🔧 핵심 구성 요소

### @entrypoint

**워크플로우의 시작점을 정의하는 데코레이터**

#### 특징
- 워크플로우 로직을 캡슐화
- 실행 흐름 관리 (long-running tasks, interrupts)
- Pregel 인스턴스로 변환되어 streaming, resumption, checkpointing 지원

#### 기본 문법
```python
from langgraph.func import entrypoint
from langgraph.checkpoint.memory import InMemorySaver

@entrypoint(checkpointer=InMemorySaver())
def my_workflow(input_data: str) -> str:
    """워크플로우 설명"""
    # 로직 구현
    return result
```

#### 직렬화 요구사항
- **입력과 출력은 JSON-serializable해야 함**
- 복잡한 객체 대신 primitives 사용 (dict, list, str, int, bool)

### @task

**비동기 실행 가능한 개별 작업 단위**

#### 특징
- 비동기 실행으로 병렬 처리 가능
- 결과가 체크포인트에 자동 저장
- future-like 객체 반환

#### 기본 문법
```python
from langgraph.func import task
import time

@task
def write_essay(topic: str) -> str:
    """에세이 작성 작업"""
    time.sleep(1)  # 긴 작업 시뮬레이션
    return f"An essay about topic: {topic}"

@entrypoint(checkpointer=InMemorySaver())
def workflow(topic: str) -> dict:
    essay = write_essay(topic).result()  # 결과 대기
    return {"essay": essay}
```

#### Task 사용 시점
- ✅ **체크포인팅**: 긴 작업 결과를 저장해야 할 때
- ✅ **Human-in-the-loop**: 비결정적 요소를 캡슐화할 때
- ✅ **병렬 실행**: I/O 바운드 작업들을 동시에 처리할 때
- ✅ **관찰성**: LangSmith로 개별 작업 추적할 때

### interrupt

**사용자 개입이 필요한 지점에서 워크플로우를 일시 중단**

#### 기본 문법
```python
from langgraph.types import interrupt

@entrypoint(checkpointer=InMemorySaver())
def workflow(topic: str) -> dict:
    essay = write_essay(topic).result()
    
    # 사용자 승인 요청
    is_approved = interrupt({
        "essay": essay,
        "action": "Please approve/reject the essay"
    })
    
    return {
        "essay": essay,
        "is_approved": is_approved
    }
```

#### 재개하기
```python
from langgraph.types import Command

# 사용자 피드백과 함께 재개
for item in workflow.stream(Command(resume=True), config):
    print(item)
```

---

## 🔥 고급 기능

### Injectable Parameters

entrypoint 함수에서 런타임에 자동으로 주입되는 특별한 매개변수들

```python
from langchain_core.runnables import RunnableConfig
from langgraph.store.base import BaseStore

@entrypoint(
    checkpointer=checkpointer,
    store=store
)
def advanced_workflow(
    user_input: str,
    *,
    previous: Any = None,           # 이전 체크포인트 상태
    store: BaseStore,               # 장기 메모리 저장소
    config: RunnableConfig         # 런타임 설정
) -> str:
    """고급 워크플로우 with 주입된 매개변수"""
    
    # 이전 상태 활용
    if previous:
        context = f"이전 결과: {previous}"
    else:
        context = "새로운 세션"
    
    # 장기 메모리에서 사용자 정보 조회
    user_data = store.get("user_preferences")
    
    # 설정 정보 활용
    thread_id = config["configurable"]["thread_id"]
    
    return f"{context} | 사용자: {user_data} | 세션: {thread_id}"
```

### Short-term Memory

이전 실행 결과를 다음 실행에서 활용하는 메모리 시스템

```python
@entrypoint(checkpointer=InMemorySaver())
def memory_workflow(number: int, *, previous: Any = None) -> int:
    """누적 계산 워크플로우"""
    previous_sum = previous or 0
    current_sum = previous_sum + number
    
    return current_sum

config = {"configurable": {"thread_id": "math_session"}}

# 첫 번째 실행
result1 = memory_workflow.invoke(5, config)    # 5
result2 = memory_workflow.invoke(3, config)    # 8 (5 + 3)
result3 = memory_workflow.invoke(2, config)    # 10 (8 + 2)
```

### entrypoint.final

반환값과 저장값을 분리하는 특별한 기능

```python
@entrypoint(checkpointer=checkpointer)
def final_example(number: int, *, previous: Any = None) -> entrypoint.final[int, str]:
    """반환값과 저장값을 분리"""
    previous_count = previous or 0
    current_count = previous_count + 1
    
    # 사용자에게는 number를 반환하지만, 
    # 메모리에는 count를 저장
    return entrypoint.final(
        value=number,           # 반환값
        save=str(current_count) # 저장값 (다음 실행의 previous)
    )
```

---

## 🎨 실전 예제

### 1. 에세이 작성 및 검토 시스템

```python
from langgraph.func import entrypoint, task
from langgraph.types import interrupt
from langgraph.checkpoint.memory import InMemorySaver
import time

@task
def write_essay(topic: str, style: str = "academic") -> str:
    """에세이 작성 태스크"""
    time.sleep(2)  # 작성 시간 시뮬레이션
    return f"""
    {style.upper()} 스타일 에세이: {topic}
    
    서론: {topic}은 현대 사회의 중요한 주제입니다...
    본론: 다양한 관점에서 살펴보면...
    결론: 따라서 {topic}은 지속적인 관심이 필요합니다.
    """

@task
def grammar_check(text: str) -> dict:
    """문법 검사 태스크"""
    time.sleep(1)
    return {
        "errors_found": 2,
        "suggestions": ["문장 구조 개선", "어휘 다양성 증대"],
        "score": 85
    }

@entrypoint(checkpointer=InMemorySaver())
def essay_workflow(topic: str, style: str = "academic") -> dict:
    """에세이 작성 및 검토 워크플로우"""
    
    # 1. 에세이 작성
    essay = write_essay(topic, style).result()
    
    # 2. 문법 검사 (병렬로 실행 가능)
    grammar_result = grammar_check(essay).result()
    
    # 3. 사용자 검토 요청
    approval = interrupt({
        "essay": essay,
        "grammar_score": grammar_result["score"],
        "suggestions": grammar_result["suggestions"],
        "action": "에세이를 승인하시겠습니까? (approve/revise/reject)"
    })
    
    # 4. 최종 결과
    return {
        "essay": essay,
        "grammar_check": grammar_result,
        "user_decision": approval,
        "final_status": "completed" if approval == "approve" else "needs_revision"
    }

# 사용 예시
import uuid

thread_id = str(uuid.uuid4())
config = {"configurable": {"thread_id": thread_id}}

# 워크플로우 시작
for item in essay_workflow.stream("인공지능의 미래", config):
    print(item)
    # interrupt가 발생하면 여기서 중단됨

# 사용자 검토 후 재개
from langgraph.types import Command
user_decision = "approve"  # 실제로는 UI에서 입력받음

for item in essay_workflow.stream(Command(resume=user_decision), config):
    print("최종 결과:", item)
```
---

## ✅ 베스트 프랙티스

### 1. 적절한 Task 분리

```python
# ✅ 좋은 예: 작업 단위별로 분리
@task
def fetch_weather(city: str) -> dict:
    """단일 책임: 날씨 데이터 가져오기"""
    return api_call(f"/weather/{city}")

@task
def process_weather(weather_data: dict) -> dict:
    """단일 책임: 날씨 데이터 처리"""
    return {"summary": f"Temperature: {weather_data['temp']}°C"}

# ❌ 나쁜 예: 너무 많은 책임
@task
def do_everything(city: str) -> dict:
    """여러 책임이 섞임"""
    weather = api_call(f"/weather/{city}")
    processed = process_data(weather)
    notification = send_alert(processed)
    return {"weather": weather, "processed": processed, "sent": notification}
```

### 2. 에러 처리

```python
@task
def safe_api_call(url: str) -> dict:
    """안전한 API 호출"""
    try:
        response = requests.get(url, timeout=10)
        return {"success": True, "data": response.json()}
    except requests.Timeout:
        return {"success": False, "error": "timeout"}
    except Exception as e:
        return {"success": False, "error": str(e)}

@entrypoint(checkpointer=InMemorySaver())
def robust_workflow(urls: list) -> dict:
    """견고한 워크플로우"""
    results = []
    failed_urls = []
    
    for url in urls:
        result = safe_api_call(url).result()
        if result["success"]:
            results.append(result["data"])
        else:
            failed_urls.append({"url": url, "error": result["error"]})
    
    # 실패가 너무 많으면 사용자에게 알림
    if len(failed_urls) > len(urls) * 0.5:
        user_decision = interrupt({
            "failed_count": len(failed_urls),
            "total_count": len(urls),
            "failed_urls": failed_urls,
            "action": "절반 이상의 요청이 실패했습니다. 계속하시겠습니까?"
        })
        
        if not user_decision:
            return {"status": "aborted", "results": results, "failures": failed_urls}
    
    return {"status": "completed", "results": results, "failures": failed_urls}
```

### 3. 메모리 관리

```python
@entrypoint(checkpointer=InMemorySaver())
def memory_managed_workflow(
    data: str,
    *,
    previous: Any = None
) -> entrypoint.final[str, dict]:
    """메모리를 효율적으로 관리하는 워크플로우"""
    
    # 이전 상태에서 필요한 정보만 추출
    processed_count = previous.get("count", 0) if previous else 0
    last_error = previous.get("last_error") if previous else None
    
    # 현재 작업 수행
    try:
        result = process_data(data)
        new_state = {
            "count": processed_count + 1,
            "last_success": True,
            "last_error": None  # 성공시 에러 정보 제거
        }
    except Exception as e:
        result = f"처리 실패: {str(e)}"
        new_state = {
            "count": processed_count,  # 실패시 카운트 증가 안 함
            "last_success": False,
            "last_error": str(e)
        }
    
    # 사용자에게는 결과만 반환하고, 메모리에는 상태 정보만 저장
    return entrypoint.final(value=result, save=new_state)
```

### 4. 타입 안정성

```python
from typing import Dict, List, Optional, Union

@task
def typed_task(
    input_data: Dict[str, Union[str, int]], 
    options: Optional[List[str]] = None
) -> Dict[str, Any]:
    """타입 힌트가 명확한 태스크"""
    if options is None:
        options = ["default"]
    
    return {
        "processed": input_data,
        "options_used": options,
        "timestamp": time.time()
    }

@entrypoint(checkpointer=InMemorySaver())
def typed_workflow(
    user_input: str,
    settings: Dict[str, bool]
) -> Dict[str, Union[str, bool, List[str]]]:
    """타입이 명확한 워크플로우"""
    
    processed = typed_task({
        "input": user_input,
        "length": len(user_input)
    }).result()
    
    return {
        "result": processed["processed"]["input"],
        "success": True,
        "enabled_features": [k for k, v in settings.items() if v]
    }
```

---

## ⚠️ 주의사항

### 1. 직렬화 제한사항

```python
# ❌ 피해야 할 것들
@entrypoint(checkpointer=InMemorySaver())
def bad_serialization(data: Any) -> Any:
    # 직렬화할 수 없는 객체들
    return {
        "function": lambda x: x + 1,        # 함수 객체
        "file": open("file.txt"),           # 파일 객체  
        "thread": threading.Thread(),       # 스레드 객체
        "datetime": datetime.now()          # datetime 객체
    }

# ✅ 올바른 방법
@entrypoint(checkpointer=InMemorySaver())
def good_serialization(data: dict) -> dict:
    return {
        "result": data.get("value", ""),
        "timestamp": time.time(),           # float (직렬화 가능)
        "status": "completed",              # string
        "count": 42,                        # int
        "flags": [True, False]              # list of bool
    }
```

### 2. 결정론적 실행

```python
# ❌ 비결정적 코드 (interrupt 시 문제 발생)
@entrypoint(checkpointer=InMemorySaver())
def non_deterministic_workflow(input_data: str) -> dict:
    # 매번 다른 결과가 나올 수 있는 코드
    random_choice = random.choice(["option1", "option2"])
    
    if random_choice == "option1":
        result = process_option1(input_data)
        approval = interrupt("Option 1 결과를 승인하시겠습니까?")
    else:
        result = process_option2(input_data)
        approval = interrupt("Option 2 결과를 승인하시겠습니까?")
    
    return {"result": result, "approved": approval}

# ✅ 결정론적 코드
@task
def make_random_choice() -> str:
    """랜덤 선택을 task로 캡슐화"""
    return random.choice(["option1", "option2"])

@entrypoint(checkpointer=InMemorySaver())
def deterministic_workflow(input_data: str) -> dict:
    # 한 번만 실행되고 결과가 저장됨
    choice = make_random_choice().result()
    
    if choice == "option1":
        result = process_option1(input_data)
        approval = interrupt("Option 1 결과를 승인하시겠습니까?")
    else:
        result = process_option2(input_data)
        approval = interrupt("Option 2 결과를 승인하시겠습니까?")
    
    return {"result": result, "approved": approval}
```

### 3. 사이드 이펙트 관리

```python
# ❌ 사이드 이펙트가 워크플로우에 직접 포함
@entrypoint(checkpointer=InMemorySaver())
def side_effect_problem(data: str) -> str:
    # 이메일 전송이 매번 실행됨!
    send_email("admin@company.com", f"Processing: {data}")
    
    result = process_data(data)
    approval = interrupt("결과를 승인하시겠습니까?")
    
    if approval:
        # 파일 쓰기도 매번 실행됨!
        with open("results.txt", "a") as f:
            f.write(f"{result}\n")
    
    return result

# ✅ 사이드 이펙트를 task로 캡슐화
@task
def send_notification(message: str) -> bool:
    """이메일 전송을 task로 캡슐화"""
    return send_email("admin@company.com", message)

@task
def save_result(result: str) -> bool:
    """파일 저장을 task로 캡슐화"""
    with open("results.txt", "a") as f:
        f.write(f"{result}\n")
    return True

@entrypoint(checkpointer=InMemorySaver())
def side_effect_solution(data: str) -> str:
    # 알림은 한 번만 전송됨
    send_notification(f"Processing: {data}").result()
    
    result = process_data(data)
    approval = interrupt("결과를 승인하시겠습니까?")
    
    if approval:
        # 저장도 한 번만 실행됨
        save_result(result).result()
    
    return result
```

---

## 🎯 언제 사용할까?

### Functional API 선택 기준

#### ✅ 적합한 상황
- **기존 코드 업그레이드**: 현재 동작하는 코드에 LangGraph 기능 추가
- **빠른 프로토타입**: 복잡한 그래프 구조 없이 빠른 개발
- **단순한 워크플로우**: 복잡한 분기나 조건이 적은 경우
- **학습 목적**: LangGraph 기능을 점진적으로 학습할 때

#### ❌ 부적합한 상황
- **복잡한 워크플로우**: 많은 조건부 분기와 복잡한 상태 관리
- **시각화 필요**: 워크플로우를 그래프로 보여줘야 하는 경우
- **팀 협업**: 여러 사람이 워크플로우 구조를 이해해야 하는 경우
- **세밀한 제어**: 각 단계별 세부적인 제어가 필요한 경우

### 선택 가이드

| 요구사항 | Functional API | Graph API |
|----------|----------------|-----------|
| **빠른 개발** | ✅ 적합 | ❌ 복잡함 |
| **기존 코드 활용** | ✅ 최적 | ❌ 재작성 필요 |
| **복잡한 로직** | ❌ 제한적 | ✅ 최적 |
| **시각화** | ❌ 미지원 | ✅ 지원 |
| **학습 용이성** | ✅ 쉬움 | ❌ 어려움 |
| **확장성** | ❌ 제한적 | ✅ 높음 |

---

## 🎉 결론

LangGraph Functional API는 **기존 코드에 최소한의 변경으로 강력한 기능을 추가할 수 있는 혁신적인 접근 방식**입니다.


### 💡 성공을 위한 팁

- **작게 시작하기**: 단순한 워크플로우부터 시작해서 점진적으로 복잡도 증가
- **적절한 task 분리**: 각 task는 단일 책임을 가지도록 설계
- **에러 처리**: 실패할 수 있는 부분에 대한 적절한 예외 처리
- **직렬화 고려**: JSON-serializable한 데이터 구조 사용

> **Functional API는 LangGraph의 강력함을 접근 가능한 형태로 제공하는 훌륭한 도구입니다. 복잡한 그래프 이론을 모르더라도 생산성 높은 AI 애플리케이션을 구축할 수 있습니다.**



## 📚 참고 자료

- [LangGraph Functional API 공식 문서](https://langchain-ai.github.io/langgraph/concepts/functional_api/)
- [Functional API How-to Guide](https://langchain-ai.github.io/langgraph/how-tos/use-functional-api/)
- [LangGraph vs Traditional Approaches](https://langchain-ai.github.io/langgraph/concepts/low_level/)
- [Checkpointing in LangGraph](https://langchain-ai.github.io/langgraph/concepts/persistence/)

---

*LangGraph Functional API는 기존 Graph API와 함께 사용할 수 있으며, 프로젝트의 요구사항에 따라 적절한 방식을 선택하여 활용할 수 있습니다.*