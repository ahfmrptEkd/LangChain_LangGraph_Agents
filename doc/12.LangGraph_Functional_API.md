# ğŸ¯ LangGraph Functional API ì™„ì „ ê°€ì´ë“œ

> ê¸°ì¡´ ì½”ë“œì— ìµœì†Œí•œì˜ ë³€ê²½ìœ¼ë¡œ LangGraph ê¸°ëŠ¥ì„ í†µí•©í•˜ëŠ” ìƒˆë¡œìš´ ë°©ì‹

## ğŸ“š ëª©ì°¨

- [Functional API ê°œìš”](#-functional-api-ê°œìš”)
- [Graph API vs Functional API](#-graph-api-vs-functional-api)
- [í•µì‹¬ êµ¬ì„± ìš”ì†Œ](#-í•µì‹¬-êµ¬ì„±-ìš”ì†Œ)
- [ê³ ê¸‰ ê¸°ëŠ¥](#-ê³ ê¸‰-ê¸°ëŠ¥)
- [ì‹¤ì „ ì˜ˆì œ](#-ì‹¤ì „-ì˜ˆì œ)
- [ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤](#-ë² ìŠ¤íŠ¸-í”„ë™í‹°ìŠ¤)
- [ì£¼ì˜ì‚¬í•­](#-ì£¼ì˜ì‚¬í•­)
- [ì–¸ì œ ì‚¬ìš©í• ê¹Œ?](#-ì–¸ì œ-ì‚¬ìš©í• ê¹Œ)
- [ê²°ë¡ ](#-ê²°ë¡ )
- [ì°¸ê³  ìë£Œ](#-ì°¸ê³ -ìë£Œ)

---

## ğŸ¯ Functional API ê°œìš”

### ì •ì˜
**Functional APIëŠ” ê¸°ì¡´ ì½”ë“œì— ìµœì†Œí•œì˜ ë³€ê²½ìœ¼ë¡œ LangGraphì˜ í•µì‹¬ ê¸°ëŠ¥ì„ í†µí•©í•  ìˆ˜ ìˆëŠ” ìƒˆë¡œìš´ ì ‘ê·¼ ë°©ì‹ì…ë‹ˆë‹¤.**

### í•µì‹¬ íŠ¹ì§•
- âœ… **ìµœì†Œ ë³€ê²½**: ê¸°ì¡´ ì½”ë“œ êµ¬ì¡° ìœ ì§€
- âœ… **í‘œì¤€ Python êµ¬ë¬¸**: `if`, `for`, í•¨ìˆ˜ í˜¸ì¶œ ë“± ê·¸ëŒ€ë¡œ ì‚¬ìš©
- âœ… **ìë™ ìƒíƒœ ê´€ë¦¬**: ëª…ì‹œì  State ì •ì˜ ë¶ˆí•„ìš”
- âœ… **ì„ íƒì  ë„ì…**: í•„ìš”í•œ ë¶€ë¶„ë§Œ ì ì§„ì  ì ìš©

### ì œê³µí•˜ëŠ” í•µì‹¬ ê¸°ëŠ¥
- ğŸ”„ **Persistence**: ìë™ ì²´í¬í¬ì¸íŒ…
- ğŸ§  **Memory**: ëŒ€í™” íˆìŠ¤í† ë¦¬ ê´€ë¦¬  
- ğŸ‘¤ **Human-in-the-loop**: ì‚¬ìš©ì ê°œì… ì§€ì 
- ğŸ“¡ **Streaming**: ì‹¤ì‹œê°„ ê²°ê³¼ ìŠ¤íŠ¸ë¦¬ë°

---

## ğŸ“Š Graph API vs Functional API

| íŠ¹ì„± | Graph API | Functional API |
|------|-----------|----------------|
| **ì œì–´ íë¦„** | ëª…ì‹œì  ê·¸ë˜í”„ êµ¬ì¡° | í‘œì¤€ Python êµ¬ë¬¸ |
| **ìƒíƒœ ê´€ë¦¬** | State í´ë˜ìŠ¤ ì •ì˜ í•„ìš” | ìë™ ê´€ë¦¬ (í•¨ìˆ˜ ìŠ¤ì½”í”„) |
| **ì½”ë“œ ì–‘** | ë§ìŒ (ê·¸ë˜í”„ ì •ì˜) | ì ìŒ (ë°ì½”ë ˆì´í„°ë§Œ) |
| **ì²´í¬í¬ì¸íŒ…** | superstepë§ˆë‹¤ ìƒˆë¡œ ìƒì„± | ê¸°ì¡´ ì²´í¬í¬ì¸íŠ¸ì— ì €ì¥ |
| **ì‹œê°í™”** | ì§€ì› (ê·¸ë˜í”„ ë·°) | ë¯¸ì§€ì› (ë™ì  ìƒì„±) |
| **í•™ìŠµ ê³¡ì„ ** | ê°€íŒŒë¦„ | ì™„ë§Œí•¨ |
| **ì ìš© ì‹œê¸°** | ìƒˆ í”„ë¡œì íŠ¸, ë³µì¡í•œ ì›Œí¬í”Œë¡œìš° | ê¸°ì¡´ ì½”ë“œ ê°œì„ , ë¹ ë¥¸ í”„ë¡œí† íƒ€ì… |

### ì½”ë“œ ë¹„êµ ì˜ˆì‹œ

**Graph API ë°©ì‹:**
```python
from langgraph.graph import StateGraph, MessagesState, START, END

def chat_node(state: MessagesState):
    response = llm.invoke(state["messages"])
    return {"messages": [response]}

# ê·¸ë˜í”„ êµ¬ì¡° ì •ì˜
workflow = StateGraph(MessagesState)
workflow.add_node("chat", chat_node)
workflow.add_edge(START, "chat")
workflow.add_edge("chat", END)

app = workflow.compile(checkpointer=checkpointer)
```

**Functional API ë°©ì‹:**
```python
from langgraph.func import entrypoint

@entrypoint(checkpointer=checkpointer)
def workflow(query: str) -> str:
    response = llm.invoke(query)
    return response
```

---

## ğŸ”§ í•µì‹¬ êµ¬ì„± ìš”ì†Œ

### @entrypoint

**ì›Œí¬í”Œë¡œìš°ì˜ ì‹œì‘ì ì„ ì •ì˜í•˜ëŠ” ë°ì½”ë ˆì´í„°**

#### íŠ¹ì§•
- ì›Œí¬í”Œë¡œìš° ë¡œì§ì„ ìº¡ìŠí™”
- ì‹¤í–‰ íë¦„ ê´€ë¦¬ (long-running tasks, interrupts)
- Pregel ì¸ìŠ¤í„´ìŠ¤ë¡œ ë³€í™˜ë˜ì–´ streaming, resumption, checkpointing ì§€ì›

#### ê¸°ë³¸ ë¬¸ë²•
```python
from langgraph.func import entrypoint
from langgraph.checkpoint.memory import InMemorySaver

@entrypoint(checkpointer=InMemorySaver())
def my_workflow(input_data: str) -> str:
    """ì›Œí¬í”Œë¡œìš° ì„¤ëª…"""
    # ë¡œì§ êµ¬í˜„
    return result
```

#### ì§ë ¬í™” ìš”êµ¬ì‚¬í•­
- **ì…ë ¥ê³¼ ì¶œë ¥ì€ JSON-serializableí•´ì•¼ í•¨**
- ë³µì¡í•œ ê°ì²´ ëŒ€ì‹  primitives ì‚¬ìš© (dict, list, str, int, bool)

### @task

**ë¹„ë™ê¸° ì‹¤í–‰ ê°€ëŠ¥í•œ ê°œë³„ ì‘ì—… ë‹¨ìœ„**

#### íŠ¹ì§•
- ë¹„ë™ê¸° ì‹¤í–‰ìœ¼ë¡œ ë³‘ë ¬ ì²˜ë¦¬ ê°€ëŠ¥
- ê²°ê³¼ê°€ ì²´í¬í¬ì¸íŠ¸ì— ìë™ ì €ì¥
- future-like ê°ì²´ ë°˜í™˜

#### ê¸°ë³¸ ë¬¸ë²•
```python
from langgraph.func import task
import time

@task
def write_essay(topic: str) -> str:
    """ì—ì„¸ì´ ì‘ì„± ì‘ì—…"""
    time.sleep(1)  # ê¸´ ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
    return f"An essay about topic: {topic}"

@entrypoint(checkpointer=InMemorySaver())
def workflow(topic: str) -> dict:
    essay = write_essay(topic).result()  # ê²°ê³¼ ëŒ€ê¸°
    return {"essay": essay}
```

#### Task ì‚¬ìš© ì‹œì 
- âœ… **ì²´í¬í¬ì¸íŒ…**: ê¸´ ì‘ì—… ê²°ê³¼ë¥¼ ì €ì¥í•´ì•¼ í•  ë•Œ
- âœ… **Human-in-the-loop**: ë¹„ê²°ì •ì  ìš”ì†Œë¥¼ ìº¡ìŠí™”í•  ë•Œ
- âœ… **ë³‘ë ¬ ì‹¤í–‰**: I/O ë°”ìš´ë“œ ì‘ì—…ë“¤ì„ ë™ì‹œì— ì²˜ë¦¬í•  ë•Œ
- âœ… **ê´€ì°°ì„±**: LangSmithë¡œ ê°œë³„ ì‘ì—… ì¶”ì í•  ë•Œ

### interrupt

**ì‚¬ìš©ì ê°œì…ì´ í•„ìš”í•œ ì§€ì ì—ì„œ ì›Œí¬í”Œë¡œìš°ë¥¼ ì¼ì‹œ ì¤‘ë‹¨**

#### ê¸°ë³¸ ë¬¸ë²•
```python
from langgraph.types import interrupt

@entrypoint(checkpointer=InMemorySaver())
def workflow(topic: str) -> dict:
    essay = write_essay(topic).result()
    
    # ì‚¬ìš©ì ìŠ¹ì¸ ìš”ì²­
    is_approved = interrupt({
        "essay": essay,
        "action": "Please approve/reject the essay"
    })
    
    return {
        "essay": essay,
        "is_approved": is_approved
    }
```

#### ì¬ê°œí•˜ê¸°
```python
from langgraph.types import Command

# ì‚¬ìš©ì í”¼ë“œë°±ê³¼ í•¨ê»˜ ì¬ê°œ
for item in workflow.stream(Command(resume=True), config):
    print(item)
```

---

## ğŸ”¥ ê³ ê¸‰ ê¸°ëŠ¥

### Injectable Parameters

entrypoint í•¨ìˆ˜ì—ì„œ ëŸ°íƒ€ì„ì— ìë™ìœ¼ë¡œ ì£¼ì…ë˜ëŠ” íŠ¹ë³„í•œ ë§¤ê°œë³€ìˆ˜ë“¤

```python
from langchain_core.runnables import RunnableConfig
from langgraph.store.base import BaseStore

@entrypoint(
    checkpointer=checkpointer,
    store=store
)
def advanced_workflow(
    user_input: str,
    *,
    previous: Any = None,           # ì´ì „ ì²´í¬í¬ì¸íŠ¸ ìƒíƒœ
    store: BaseStore,               # ì¥ê¸° ë©”ëª¨ë¦¬ ì €ì¥ì†Œ
    config: RunnableConfig         # ëŸ°íƒ€ì„ ì„¤ì •
) -> str:
    """ê³ ê¸‰ ì›Œí¬í”Œë¡œìš° with ì£¼ì…ëœ ë§¤ê°œë³€ìˆ˜"""
    
    # ì´ì „ ìƒíƒœ í™œìš©
    if previous:
        context = f"ì´ì „ ê²°ê³¼: {previous}"
    else:
        context = "ìƒˆë¡œìš´ ì„¸ì…˜"
    
    # ì¥ê¸° ë©”ëª¨ë¦¬ì—ì„œ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
    user_data = store.get("user_preferences")
    
    # ì„¤ì • ì •ë³´ í™œìš©
    thread_id = config["configurable"]["thread_id"]
    
    return f"{context} | ì‚¬ìš©ì: {user_data} | ì„¸ì…˜: {thread_id}"
```

### Short-term Memory

ì´ì „ ì‹¤í–‰ ê²°ê³¼ë¥¼ ë‹¤ìŒ ì‹¤í–‰ì—ì„œ í™œìš©í•˜ëŠ” ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ

```python
@entrypoint(checkpointer=InMemorySaver())
def memory_workflow(number: int, *, previous: Any = None) -> int:
    """ëˆ„ì  ê³„ì‚° ì›Œí¬í”Œë¡œìš°"""
    previous_sum = previous or 0
    current_sum = previous_sum + number
    
    return current_sum

config = {"configurable": {"thread_id": "math_session"}}

# ì²« ë²ˆì§¸ ì‹¤í–‰
result1 = memory_workflow.invoke(5, config)    # 5
result2 = memory_workflow.invoke(3, config)    # 8 (5 + 3)
result3 = memory_workflow.invoke(2, config)    # 10 (8 + 2)
```

### entrypoint.final

ë°˜í™˜ê°’ê³¼ ì €ì¥ê°’ì„ ë¶„ë¦¬í•˜ëŠ” íŠ¹ë³„í•œ ê¸°ëŠ¥

```python
@entrypoint(checkpointer=checkpointer)
def final_example(number: int, *, previous: Any = None) -> entrypoint.final[int, str]:
    """ë°˜í™˜ê°’ê³¼ ì €ì¥ê°’ì„ ë¶„ë¦¬"""
    previous_count = previous or 0
    current_count = previous_count + 1
    
    # ì‚¬ìš©ìì—ê²ŒëŠ” numberë¥¼ ë°˜í™˜í•˜ì§€ë§Œ, 
    # ë©”ëª¨ë¦¬ì—ëŠ” countë¥¼ ì €ì¥
    return entrypoint.final(
        value=number,           # ë°˜í™˜ê°’
        save=str(current_count) # ì €ì¥ê°’ (ë‹¤ìŒ ì‹¤í–‰ì˜ previous)
    )
```

---

## ğŸ¨ ì‹¤ì „ ì˜ˆì œ

### 1. ì—ì„¸ì´ ì‘ì„± ë° ê²€í†  ì‹œìŠ¤í…œ

```python
from langgraph.func import entrypoint, task
from langgraph.types import interrupt
from langgraph.checkpoint.memory import InMemorySaver
import time

@task
def write_essay(topic: str, style: str = "academic") -> str:
    """ì—ì„¸ì´ ì‘ì„± íƒœìŠ¤í¬"""
    time.sleep(2)  # ì‘ì„± ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜
    return f"""
    {style.upper()} ìŠ¤íƒ€ì¼ ì—ì„¸ì´: {topic}
    
    ì„œë¡ : {topic}ì€ í˜„ëŒ€ ì‚¬íšŒì˜ ì¤‘ìš”í•œ ì£¼ì œì…ë‹ˆë‹¤...
    ë³¸ë¡ : ë‹¤ì–‘í•œ ê´€ì ì—ì„œ ì‚´í´ë³´ë©´...
    ê²°ë¡ : ë”°ë¼ì„œ {topic}ì€ ì§€ì†ì ì¸ ê´€ì‹¬ì´ í•„ìš”í•©ë‹ˆë‹¤.
    """

@task
def grammar_check(text: str) -> dict:
    """ë¬¸ë²• ê²€ì‚¬ íƒœìŠ¤í¬"""
    time.sleep(1)
    return {
        "errors_found": 2,
        "suggestions": ["ë¬¸ì¥ êµ¬ì¡° ê°œì„ ", "ì–´íœ˜ ë‹¤ì–‘ì„± ì¦ëŒ€"],
        "score": 85
    }

@entrypoint(checkpointer=InMemorySaver())
def essay_workflow(topic: str, style: str = "academic") -> dict:
    """ì—ì„¸ì´ ì‘ì„± ë° ê²€í†  ì›Œí¬í”Œë¡œìš°"""
    
    # 1. ì—ì„¸ì´ ì‘ì„±
    essay = write_essay(topic, style).result()
    
    # 2. ë¬¸ë²• ê²€ì‚¬ (ë³‘ë ¬ë¡œ ì‹¤í–‰ ê°€ëŠ¥)
    grammar_result = grammar_check(essay).result()
    
    # 3. ì‚¬ìš©ì ê²€í†  ìš”ì²­
    approval = interrupt({
        "essay": essay,
        "grammar_score": grammar_result["score"],
        "suggestions": grammar_result["suggestions"],
        "action": "ì—ì„¸ì´ë¥¼ ìŠ¹ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (approve/revise/reject)"
    })
    
    # 4. ìµœì¢… ê²°ê³¼
    return {
        "essay": essay,
        "grammar_check": grammar_result,
        "user_decision": approval,
        "final_status": "completed" if approval == "approve" else "needs_revision"
    }

# ì‚¬ìš© ì˜ˆì‹œ
import uuid

thread_id = str(uuid.uuid4())
config = {"configurable": {"thread_id": thread_id}}

# ì›Œí¬í”Œë¡œìš° ì‹œì‘
for item in essay_workflow.stream("ì¸ê³µì§€ëŠ¥ì˜ ë¯¸ë˜", config):
    print(item)
    # interruptê°€ ë°œìƒí•˜ë©´ ì—¬ê¸°ì„œ ì¤‘ë‹¨ë¨

# ì‚¬ìš©ì ê²€í†  í›„ ì¬ê°œ
from langgraph.types import Command
user_decision = "approve"  # ì‹¤ì œë¡œëŠ” UIì—ì„œ ì…ë ¥ë°›ìŒ

for item in essay_workflow.stream(Command(resume=user_decision), config):
    print("ìµœì¢… ê²°ê³¼:", item)
```
---

## âœ… ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

### 1. ì ì ˆí•œ Task ë¶„ë¦¬

```python
# âœ… ì¢‹ì€ ì˜ˆ: ì‘ì—… ë‹¨ìœ„ë³„ë¡œ ë¶„ë¦¬
@task
def fetch_weather(city: str) -> dict:
    """ë‹¨ì¼ ì±…ì„: ë‚ ì”¨ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°"""
    return api_call(f"/weather/{city}")

@task
def process_weather(weather_data: dict) -> dict:
    """ë‹¨ì¼ ì±…ì„: ë‚ ì”¨ ë°ì´í„° ì²˜ë¦¬"""
    return {"summary": f"Temperature: {weather_data['temp']}Â°C"}

# âŒ ë‚˜ìœ ì˜ˆ: ë„ˆë¬´ ë§ì€ ì±…ì„
@task
def do_everything(city: str) -> dict:
    """ì—¬ëŸ¬ ì±…ì„ì´ ì„ì„"""
    weather = api_call(f"/weather/{city}")
    processed = process_data(weather)
    notification = send_alert(processed)
    return {"weather": weather, "processed": processed, "sent": notification}
```

### 2. ì—ëŸ¬ ì²˜ë¦¬

```python
@task
def safe_api_call(url: str) -> dict:
    """ì•ˆì „í•œ API í˜¸ì¶œ"""
    try:
        response = requests.get(url, timeout=10)
        return {"success": True, "data": response.json()}
    except requests.Timeout:
        return {"success": False, "error": "timeout"}
    except Exception as e:
        return {"success": False, "error": str(e)}

@entrypoint(checkpointer=InMemorySaver())
def robust_workflow(urls: list) -> dict:
    """ê²¬ê³ í•œ ì›Œí¬í”Œë¡œìš°"""
    results = []
    failed_urls = []
    
    for url in urls:
        result = safe_api_call(url).result()
        if result["success"]:
            results.append(result["data"])
        else:
            failed_urls.append({"url": url, "error": result["error"]})
    
    # ì‹¤íŒ¨ê°€ ë„ˆë¬´ ë§ìœ¼ë©´ ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼
    if len(failed_urls) > len(urls) * 0.5:
        user_decision = interrupt({
            "failed_count": len(failed_urls),
            "total_count": len(urls),
            "failed_urls": failed_urls,
            "action": "ì ˆë°˜ ì´ìƒì˜ ìš”ì²­ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?"
        })
        
        if not user_decision:
            return {"status": "aborted", "results": results, "failures": failed_urls}
    
    return {"status": "completed", "results": results, "failures": failed_urls}
```

### 3. ë©”ëª¨ë¦¬ ê´€ë¦¬

```python
@entrypoint(checkpointer=InMemorySaver())
def memory_managed_workflow(
    data: str,
    *,
    previous: Any = None
) -> entrypoint.final[str, dict]:
    """ë©”ëª¨ë¦¬ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ì›Œí¬í”Œë¡œìš°"""
    
    # ì´ì „ ìƒíƒœì—ì„œ í•„ìš”í•œ ì •ë³´ë§Œ ì¶”ì¶œ
    processed_count = previous.get("count", 0) if previous else 0
    last_error = previous.get("last_error") if previous else None
    
    # í˜„ì¬ ì‘ì—… ìˆ˜í–‰
    try:
        result = process_data(data)
        new_state = {
            "count": processed_count + 1,
            "last_success": True,
            "last_error": None  # ì„±ê³µì‹œ ì—ëŸ¬ ì •ë³´ ì œê±°
        }
    except Exception as e:
        result = f"ì²˜ë¦¬ ì‹¤íŒ¨: {str(e)}"
        new_state = {
            "count": processed_count,  # ì‹¤íŒ¨ì‹œ ì¹´ìš´íŠ¸ ì¦ê°€ ì•ˆ í•¨
            "last_success": False,
            "last_error": str(e)
        }
    
    # ì‚¬ìš©ìì—ê²ŒëŠ” ê²°ê³¼ë§Œ ë°˜í™˜í•˜ê³ , ë©”ëª¨ë¦¬ì—ëŠ” ìƒíƒœ ì •ë³´ë§Œ ì €ì¥
    return entrypoint.final(value=result, save=new_state)
```

### 4. íƒ€ì… ì•ˆì •ì„±

```python
from typing import Dict, List, Optional, Union

@task
def typed_task(
    input_data: Dict[str, Union[str, int]], 
    options: Optional[List[str]] = None
) -> Dict[str, Any]:
    """íƒ€ì… íŒíŠ¸ê°€ ëª…í™•í•œ íƒœìŠ¤í¬"""
    if options is None:
        options = ["default"]
    
    return {
        "processed": input_data,
        "options_used": options,
        "timestamp": time.time()
    }

@entrypoint(checkpointer=InMemorySaver())
def typed_workflow(
    user_input: str,
    settings: Dict[str, bool]
) -> Dict[str, Union[str, bool, List[str]]]:
    """íƒ€ì…ì´ ëª…í™•í•œ ì›Œí¬í”Œë¡œìš°"""
    
    processed = typed_task({
        "input": user_input,
        "length": len(user_input)
    }).result()
    
    return {
        "result": processed["processed"]["input"],
        "success": True,
        "enabled_features": [k for k, v in settings.items() if v]
    }
```

---

## âš ï¸ ì£¼ì˜ì‚¬í•­

### 1. ì§ë ¬í™” ì œí•œì‚¬í•­

```python
# âŒ í”¼í•´ì•¼ í•  ê²ƒë“¤
@entrypoint(checkpointer=InMemorySaver())
def bad_serialization(data: Any) -> Any:
    # ì§ë ¬í™”í•  ìˆ˜ ì—†ëŠ” ê°ì²´ë“¤
    return {
        "function": lambda x: x + 1,        # í•¨ìˆ˜ ê°ì²´
        "file": open("file.txt"),           # íŒŒì¼ ê°ì²´  
        "thread": threading.Thread(),       # ìŠ¤ë ˆë“œ ê°ì²´
        "datetime": datetime.now()          # datetime ê°ì²´
    }

# âœ… ì˜¬ë°”ë¥¸ ë°©ë²•
@entrypoint(checkpointer=InMemorySaver())
def good_serialization(data: dict) -> dict:
    return {
        "result": data.get("value", ""),
        "timestamp": time.time(),           # float (ì§ë ¬í™” ê°€ëŠ¥)
        "status": "completed",              # string
        "count": 42,                        # int
        "flags": [True, False]              # list of bool
    }
```

### 2. ê²°ì •ë¡ ì  ì‹¤í–‰

```python
# âŒ ë¹„ê²°ì •ì  ì½”ë“œ (interrupt ì‹œ ë¬¸ì œ ë°œìƒ)
@entrypoint(checkpointer=InMemorySaver())
def non_deterministic_workflow(input_data: str) -> dict:
    # ë§¤ë²ˆ ë‹¤ë¥¸ ê²°ê³¼ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ì½”ë“œ
    random_choice = random.choice(["option1", "option2"])
    
    if random_choice == "option1":
        result = process_option1(input_data)
        approval = interrupt("Option 1 ê²°ê³¼ë¥¼ ìŠ¹ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
    else:
        result = process_option2(input_data)
        approval = interrupt("Option 2 ê²°ê³¼ë¥¼ ìŠ¹ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
    
    return {"result": result, "approved": approval}

# âœ… ê²°ì •ë¡ ì  ì½”ë“œ
@task
def make_random_choice() -> str:
    """ëœë¤ ì„ íƒì„ taskë¡œ ìº¡ìŠí™”"""
    return random.choice(["option1", "option2"])

@entrypoint(checkpointer=InMemorySaver())
def deterministic_workflow(input_data: str) -> dict:
    # í•œ ë²ˆë§Œ ì‹¤í–‰ë˜ê³  ê²°ê³¼ê°€ ì €ì¥ë¨
    choice = make_random_choice().result()
    
    if choice == "option1":
        result = process_option1(input_data)
        approval = interrupt("Option 1 ê²°ê³¼ë¥¼ ìŠ¹ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
    else:
        result = process_option2(input_data)
        approval = interrupt("Option 2 ê²°ê³¼ë¥¼ ìŠ¹ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
    
    return {"result": result, "approved": approval}
```

### 3. ì‚¬ì´ë“œ ì´í™íŠ¸ ê´€ë¦¬

```python
# âŒ ì‚¬ì´ë“œ ì´í™íŠ¸ê°€ ì›Œí¬í”Œë¡œìš°ì— ì§ì ‘ í¬í•¨
@entrypoint(checkpointer=InMemorySaver())
def side_effect_problem(data: str) -> str:
    # ì´ë©”ì¼ ì „ì†¡ì´ ë§¤ë²ˆ ì‹¤í–‰ë¨!
    send_email("admin@company.com", f"Processing: {data}")
    
    result = process_data(data)
    approval = interrupt("ê²°ê³¼ë¥¼ ìŠ¹ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
    
    if approval:
        # íŒŒì¼ ì“°ê¸°ë„ ë§¤ë²ˆ ì‹¤í–‰ë¨!
        with open("results.txt", "a") as f:
            f.write(f"{result}\n")
    
    return result

# âœ… ì‚¬ì´ë“œ ì´í™íŠ¸ë¥¼ taskë¡œ ìº¡ìŠí™”
@task
def send_notification(message: str) -> bool:
    """ì´ë©”ì¼ ì „ì†¡ì„ taskë¡œ ìº¡ìŠí™”"""
    return send_email("admin@company.com", message)

@task
def save_result(result: str) -> bool:
    """íŒŒì¼ ì €ì¥ì„ taskë¡œ ìº¡ìŠí™”"""
    with open("results.txt", "a") as f:
        f.write(f"{result}\n")
    return True

@entrypoint(checkpointer=InMemorySaver())
def side_effect_solution(data: str) -> str:
    # ì•Œë¦¼ì€ í•œ ë²ˆë§Œ ì „ì†¡ë¨
    send_notification(f"Processing: {data}").result()
    
    result = process_data(data)
    approval = interrupt("ê²°ê³¼ë¥¼ ìŠ¹ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
    
    if approval:
        # ì €ì¥ë„ í•œ ë²ˆë§Œ ì‹¤í–‰ë¨
        save_result(result).result()
    
    return result
```

---

## ğŸ¯ ì–¸ì œ ì‚¬ìš©í• ê¹Œ?

### Functional API ì„ íƒ ê¸°ì¤€

#### âœ… ì í•©í•œ ìƒí™©
- **ê¸°ì¡´ ì½”ë“œ ì—…ê·¸ë ˆì´ë“œ**: í˜„ì¬ ë™ì‘í•˜ëŠ” ì½”ë“œì— LangGraph ê¸°ëŠ¥ ì¶”ê°€
- **ë¹ ë¥¸ í”„ë¡œí† íƒ€ì…**: ë³µì¡í•œ ê·¸ë˜í”„ êµ¬ì¡° ì—†ì´ ë¹ ë¥¸ ê°œë°œ
- **ë‹¨ìˆœí•œ ì›Œí¬í”Œë¡œìš°**: ë³µì¡í•œ ë¶„ê¸°ë‚˜ ì¡°ê±´ì´ ì ì€ ê²½ìš°
- **í•™ìŠµ ëª©ì **: LangGraph ê¸°ëŠ¥ì„ ì ì§„ì ìœ¼ë¡œ í•™ìŠµí•  ë•Œ

#### âŒ ë¶€ì í•©í•œ ìƒí™©
- **ë³µì¡í•œ ì›Œí¬í”Œë¡œìš°**: ë§ì€ ì¡°ê±´ë¶€ ë¶„ê¸°ì™€ ë³µì¡í•œ ìƒíƒœ ê´€ë¦¬
- **ì‹œê°í™” í•„ìš”**: ì›Œí¬í”Œë¡œìš°ë¥¼ ê·¸ë˜í”„ë¡œ ë³´ì—¬ì¤˜ì•¼ í•˜ëŠ” ê²½ìš°
- **íŒ€ í˜‘ì—…**: ì—¬ëŸ¬ ì‚¬ëŒì´ ì›Œí¬í”Œë¡œìš° êµ¬ì¡°ë¥¼ ì´í•´í•´ì•¼ í•˜ëŠ” ê²½ìš°
- **ì„¸ë°€í•œ ì œì–´**: ê° ë‹¨ê³„ë³„ ì„¸ë¶€ì ì¸ ì œì–´ê°€ í•„ìš”í•œ ê²½ìš°

### ì„ íƒ ê°€ì´ë“œ

| ìš”êµ¬ì‚¬í•­ | Functional API | Graph API |
|----------|----------------|-----------|
| **ë¹ ë¥¸ ê°œë°œ** | âœ… ì í•© | âŒ ë³µì¡í•¨ |
| **ê¸°ì¡´ ì½”ë“œ í™œìš©** | âœ… ìµœì  | âŒ ì¬ì‘ì„± í•„ìš” |
| **ë³µì¡í•œ ë¡œì§** | âŒ ì œí•œì  | âœ… ìµœì  |
| **ì‹œê°í™”** | âŒ ë¯¸ì§€ì› | âœ… ì§€ì› |
| **í•™ìŠµ ìš©ì´ì„±** | âœ… ì‰¬ì›€ | âŒ ì–´ë ¤ì›€ |
| **í™•ì¥ì„±** | âŒ ì œí•œì  | âœ… ë†’ìŒ |

---

## ğŸ‰ ê²°ë¡ 

LangGraph Functional APIëŠ” **ê¸°ì¡´ ì½”ë“œì— ìµœì†Œí•œì˜ ë³€ê²½ìœ¼ë¡œ ê°•ë ¥í•œ ê¸°ëŠ¥ì„ ì¶”ê°€í•  ìˆ˜ ìˆëŠ” í˜ì‹ ì ì¸ ì ‘ê·¼ ë°©ì‹**ì…ë‹ˆë‹¤.


### ğŸ’¡ ì„±ê³µì„ ìœ„í•œ íŒ

- **ì‘ê²Œ ì‹œì‘í•˜ê¸°**: ë‹¨ìˆœí•œ ì›Œí¬í”Œë¡œìš°ë¶€í„° ì‹œì‘í•´ì„œ ì ì§„ì ìœ¼ë¡œ ë³µì¡ë„ ì¦ê°€
- **ì ì ˆí•œ task ë¶„ë¦¬**: ê° taskëŠ” ë‹¨ì¼ ì±…ì„ì„ ê°€ì§€ë„ë¡ ì„¤ê³„
- **ì—ëŸ¬ ì²˜ë¦¬**: ì‹¤íŒ¨í•  ìˆ˜ ìˆëŠ” ë¶€ë¶„ì— ëŒ€í•œ ì ì ˆí•œ ì˜ˆì™¸ ì²˜ë¦¬
- **ì§ë ¬í™” ê³ ë ¤**: JSON-serializableí•œ ë°ì´í„° êµ¬ì¡° ì‚¬ìš©

> **Functional APIëŠ” LangGraphì˜ ê°•ë ¥í•¨ì„ ì ‘ê·¼ ê°€ëŠ¥í•œ í˜•íƒœë¡œ ì œê³µí•˜ëŠ” í›Œë¥­í•œ ë„êµ¬ì…ë‹ˆë‹¤. ë³µì¡í•œ ê·¸ë˜í”„ ì´ë¡ ì„ ëª¨ë¥´ë”ë¼ë„ ìƒì‚°ì„± ë†’ì€ AI ì• í”Œë¦¬ì¼€ì´ì…˜ì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.**



## ğŸ“š ì°¸ê³  ìë£Œ

- [LangGraph Functional API ê³µì‹ ë¬¸ì„œ](https://langchain-ai.github.io/langgraph/concepts/functional_api/)
- [Functional API How-to Guide](https://langchain-ai.github.io/langgraph/how-tos/use-functional-api/)
- [LangGraph vs Traditional Approaches](https://langchain-ai.github.io/langgraph/concepts/low_level/)
- [Checkpointing in LangGraph](https://langchain-ai.github.io/langgraph/concepts/persistence/)

---

*LangGraph Functional APIëŠ” ê¸°ì¡´ Graph APIì™€ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©°, í”„ë¡œì íŠ¸ì˜ ìš”êµ¬ì‚¬í•­ì— ë”°ë¼ ì ì ˆí•œ ë°©ì‹ì„ ì„ íƒí•˜ì—¬ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.*