# 🤖 LangGraph Multi-Agent 디자인 패턴 완전 가이드

> 복잡한 AI 시스템을 위한 다양한 멀티 에이전트 아키텍처 패턴과 설계 전략

## 📚 목차

- [Multi-Agent 시스템 개요](#-multi-agent-시스템-개요)
- [아키텍처 패턴 개요](#-아키텍처-패턴-개요)
- [1. Network 아키텍처](#️-1-network-아키텍처)
- [2. Supervisor 아키텍처](#-2-supervisor-아키텍처)
- [3. Supervisor (Tool-calling) 아키텍처](#️-3-supervisor-tool-calling-아키텍처)
- [4. Hierarchical 아키텍처](#-4-hierarchical-아키텍처)
- [5. Custom Multi-Agent Workflow](#-5-custom-multi-agent-workflow)
- [Handoffs와 Communication](#-handoffs와-communication)
- [State 관리 전략](#️-state-관리-전략)
- [실전 설계 가이드](#-실전-설계-가이드)
- [패턴 선택 가이드](#-패턴-선택-가이드)
- [베스트 프랙티스](#-베스트-프랙티스)
- [결론](#-결론)

---

## 🎯 Multi-Agent 시스템 개요

### 정의
**Multi-Agent 시스템은 여러 개의 독립적인 에이전트들이 협력하여 복잡한 작업을 수행하는 AI 아키텍처다.**

### 언제 Multi-Agent가 필요한가?

#### 단일 Agent의 한계
- ❌ **도구 과부하**: 너무 많은 도구로 인한 잘못된 선택
- ❌ **컨텍스트 복잡성**: 단일 에이전트가 추적하기 어려운 복잡한 상황
- ❌ **전문성 부족**: 여러 전문 분야를 하나의 에이전트가 처리하기 어려움

#### Multi-Agent의 이점
- ✅ **모듈성**: 개발, 테스트, 유지보수 용이성
- ✅ **전문화**: 도메인별 전문 에이전트로 성능 향상
- ✅ **제어**: 에이전트 간 명시적 통신 제어 가능

---

## 📊 아키텍처 패턴 개요

![image](../src/imgs/architectures.png)

| 패턴 | 복잡도 | 제어 방식 | 확장성 | 주요 사용 사례 |
|------|--------|-----------|--------|---------------|
| **Network** | 높음 | 분산형 | 중간 | 동등한 에이전트들의 협력 |
| **Supervisor** | 중간 | 중앙집중형 | 높음 | 명확한 역할 분담 |
| **Supervisor (Tool-calling)** | 낮음 | 중앙집중형 | 높음 | 간단한 에이전트 조정 |
| **Hierarchical** | 높음 | 계층형 | 매우 높음 | 대규모 복잡한 시스템 |
| **Custom Workflow** | 다양 | 혼합형 | 중간 | 특정 워크플로우 |

---

## 🕸️ 1. Network 아키텍처

### 특징
- **Many-to-Many 연결**: 모든 에이전트가 서로 직접 통신 가능
- **분산 의사결정**: 각 에이전트가 다음 호출할 에이전트 결정
- **비계층적**: 명확한 상하 관계 없음

### 구현 예시

```python
from typing import Literal
from langchain_openai import ChatOpenAI
from langgraph.types import Command
from langgraph.graph import StateGraph, MessagesState, START, END

model = ChatOpenAI()

def researcher_agent(state: MessagesState) -> Command[Literal["writer_agent", "reviewer_agent", END]]:
    """연구 전담 에이전트"""
    messages = state["messages"]
    
    # 연구 작업 수행
    research_prompt = f"다음 주제에 대해 연구하세요: {messages[-1].content}"
    response = model.invoke([{"role": "system", "content": "당신은 전문 연구원입니다."}, 
                           {"role": "user", "content": research_prompt}])
    
    # 다음 에이전트 결정
    if "작성" in response.content:
        next_agent = "writer_agent"
    elif "검토" in response.content:
        next_agent = "reviewer_agent"
    else:
        next_agent = END
    
    return Command(
        goto=next_agent,
        update={"messages": [response]}
    )

def writer_agent(state: MessagesState) -> Command[Literal["researcher_agent", "reviewer_agent", END]]:
    """작성 전담 에이전트"""
    messages = state["messages"]
    
    # 작성 작업 수행
    writing_prompt = f"다음 연구 내용을 바탕으로 글을 작성하세요: {messages[-1].content}"
    response = model.invoke([{"role": "system", "content": "당신은 전문 작가입니다."}, 
                           {"role": "user", "content": writing_prompt}])
    
    # 다음 에이전트 결정 로직
    if "추가 연구" in response.content:
        next_agent = "researcher_agent"
    elif "검토" in response.content:
        next_agent = "reviewer_agent"
    else:
        next_agent = END
    
    return Command(
        goto=next_agent,
        update={"messages": [response]}
    )

def reviewer_agent(state: MessagesState) -> Command[Literal["researcher_agent", "writer_agent", END]]:
    """검토 전담 에이전트"""
    messages = state["messages"]
    
    # 검토 작업 수행
    review_prompt = f"다음 내용을 검토하세요: {messages[-1].content}"
    response = model.invoke([{"role": "system", "content": "당신은 전문 검토자입니다."}, 
                           {"role": "user", "content": review_prompt}])
    
    # 다음 에이전트 결정 로직
    if "수정 필요" in response.content:
        next_agent = "writer_agent"
    elif "추가 정보" in response.content:
        next_agent = "researcher_agent"
    else:
        next_agent = END
    
    return Command(
        goto=next_agent,
        update={"messages": [response]}
    )

# 네트워크 그래프 구성
builder = StateGraph(MessagesState)
builder.add_node("researcher_agent", researcher_agent)
builder.add_node("writer_agent", writer_agent)
builder.add_node("reviewer_agent", reviewer_agent)
builder.add_edge(START, "researcher_agent")

network = builder.compile()
```

### 장점과 단점

**장점:**
- ✅ **유연성**: 동적인 상황에 적응적 대응
- ✅ **자율성**: 각 에이전트의 독립적 판단

**단점:**
- ❌ **복잡성**: 예측하기 어려운 실행 경로
- ❌ **무한 루프 위험**: 에이전트 간 순환 호출 가능성

### 적용 사례
- 브레인스토밍 시스템
- 창의적 문제 해결
- 동등한 전문가들의 협력

---

## 👨‍💼 2. Supervisor 아키텍처

### 특징
- **중앙집중식 제어**: 수퍼바이저가 모든 라우팅 결정
- **단방향 통신**: 에이전트들은 수퍼바이저를 통해서만 통신
- **명확한 제어**: 예측 가능한 실행 흐름

### 구현 예시

```python
from typing import Literal
from langchain_openai import ChatOpenAI
from langgraph.types import Command
from langgraph.graph import StateGraph, MessagesState, START, END

model = ChatOpenAI()

def supervisor(state: MessagesState) -> Command[Literal["research_agent", "writing_agent", "review_agent", END]]:
    """중앙 조정자"""
    messages = state["messages"]
    
    # 구조화된 출력으로 다음 에이전트 결정
    routing_prompt = f"""
    현재 대화 상황을 분석하고 다음 중 적절한 에이전트를 선택하세요:
    - research_agent: 정보 수집이 필요한 경우
    - writing_agent: 콘텐츠 작성이 필요한 경우  
    - review_agent: 검토가 필요한 경우
    - __end__: 작업이 완료된 경우
    
    대화: {messages[-1].content}
    
    응답 형식: {{"next_agent": "agent_name", "reason": "선택 이유"}}
    """
    
    response = model.invoke([
        {"role": "system", "content": "당신은 작업을 조정하는 수퍼바이저입니다."},
        {"role": "user", "content": routing_prompt}
    ])
    
    # 실제로는 structured output 사용 권장
    next_agent = "research_agent"  # 파싱된 결과
    
    return Command(goto=next_agent)

def research_agent(state: MessagesState) -> Command[Literal["supervisor"]]:
    """연구 전문 에이전트"""
    messages = state["messages"]
    
    research_response = model.invoke([
        {"role": "system", "content": "당신은 정보 수집 전문가입니다."},
        {"role": "user", "content": f"다음에 대해 연구하세요: {messages[-1].content}"}
    ])
    
    return Command(
        goto="supervisor",
        update={"messages": [research_response]}
    )

def writing_agent(state: MessagesState) -> Command[Literal["supervisor"]]:
    """작성 전문 에이전트"""
    messages = state["messages"]
    
    writing_response = model.invoke([
        {"role": "system", "content": "당신은 콘텐츠 작성 전문가입니다."},
        {"role": "user", "content": f"다음을 바탕으로 글을 작성하세요: {messages[-1].content}"}
    ])
    
    return Command(
        goto="supervisor",
        update={"messages": [writing_response]}
    )

def review_agent(state: MessagesState) -> Command[Literal["supervisor"]]:
    """검토 전문 에이전트"""
    messages = state["messages"]
    
    review_response = model.invoke([
        {"role": "system", "content": "당신은 품질 검토 전문가입니다."},
        {"role": "user", "content": f"다음을 검토하세요: {messages[-1].content}"}
    ])
    
    return Command(
        goto="supervisor",
        update={"messages": [review_response]}
    )

# 수퍼바이저 그래프 구성
builder = StateGraph(MessagesState)
builder.add_node("supervisor", supervisor)
builder.add_node("research_agent", research_agent)
builder.add_node("writing_agent", writing_agent)
builder.add_node("review_agent", review_agent)

builder.add_edge(START, "supervisor")
builder.add_edge("research_agent", "supervisor")
builder.add_edge("writing_agent", "supervisor")
builder.add_edge("review_agent", "supervisor")

supervisor_system = builder.compile()
```

### 병렬 처리 확장

```python
from langgraph.constants import Send

def parallel_supervisor(state: MessagesState):
    """병렬 처리가 가능한 수퍼바이저"""
    tasks = state.get("pending_tasks", [])
    
    # 여러 에이전트에게 동시에 작업 분배
    parallel_sends = []
    for task in tasks:
        if task["type"] == "research":
            parallel_sends.append(Send("research_agent", {"task": task}))
        elif task["type"] == "writing":
            parallel_sends.append(Send("writing_agent", {"task": task}))
    
    return parallel_sends
```

### 장점과 단점

**장점:**
- ✅ **예측 가능성**: 명확한 제어 흐름
- ✅ **확장성**: 새로운 에이전트 추가 용이
- ✅ **병렬 처리**: Map-Reduce 패턴 적용 가능

**단점:**
- ❌ **중앙 집중**: 수퍼바이저가 병목점이 될 수 있음
- ❌ **복잡한 라우팅**: 에이전트 수 증가 시 라우팅 로직 복잡화

---

## 🛠️ 3. Supervisor (Tool-calling) 아키텍처

### 특징
- **도구로서의 에이전트**: 각 에이전트가 도구로 표현됨
- **표준 ReAct 패턴**: 수퍼바이저가 일반적인 tool-calling 에이전트
- **간단한 구현**: 기존 도구 사용 패턴 활용

### 구현 예시

```python
from typing import Annotated
from langchain_core.tools import tool
from langchain_openai import ChatOpenAI
from langgraph.prebuilt import InjectedState, create_react_agent

model = ChatOpenAI()

@tool
def research_agent(
    query: str,
    state: Annotated[dict, InjectedState]
) -> str:
    """정보를 연구하고 수집하는 에이전트
    
    Args:
        query: 연구할 주제나 질문
        state: 현재 대화 상태
    """
    messages = state.get("messages", [])
    
    research_response = model.invoke([
        {"role": "system", "content": "당신은 정보 수집 전문가입니다."},
        {"role": "user", "content": f"다음에 대해 연구하세요: {query}"}
    ])
    
    return research_response.content

@tool
def writing_agent(
    content: str,
    style: str = "professional",
    state: Annotated[dict, InjectedState] = None
) -> str:
    """콘텐츠를 작성하는 에이전트
    
    Args:
        content: 작성할 내용의 기반 정보
        style: 작성 스타일 (professional, casual, academic)
        state: 현재 대화 상태
    """
    writing_response = model.invoke([
        {"role": "system", "content": f"당신은 {style} 스타일의 작성 전문가입니다."},
        {"role": "user", "content": f"다음을 바탕으로 글을 작성하세요: {content}"}
    ])
    
    return writing_response.content

@tool
def review_agent(
    content: str,
    criteria: str = "accuracy and clarity",
    state: Annotated[dict, InjectedState] = None
) -> str:
    """콘텐츠를 검토하는 에이전트
    
    Args:
        content: 검토할 콘텐츠
        criteria: 검토 기준
        state: 현재 대화 상태
    """
    review_response = model.invoke([
        {"role": "system", "content": f"당신은 {criteria} 기준으로 검토하는 전문가입니다."},
        {"role": "user", "content": f"다음을 검토하세요: {content}"}
    ])
    
    return review_response.content

# 도구 목록
tools = [research_agent, writing_agent, review_agent]

# 수퍼바이저 에이전트 생성 (사전 구축된 ReAct 에이전트 사용)
supervisor_agent = create_react_agent(model, tools)
```

### Handoff 도구 패턴

```python
from langgraph.types import Command

@tool
def transfer_to_specialist(
    specialist_type: str,
    task_description: str,
    context: str = ""
) -> Command:
    """전문가에게 작업을 이양하는 도구
    
    Args:
        specialist_type: 전문가 유형 (researcher, writer, reviewer)
        task_description: 작업 설명
        context: 추가 컨텍스트
    """
    return Command(
        goto=f"{specialist_type}_agent",
        update={
            "current_task": task_description,
            "context": context
        },
        graph=Command.PARENT  # 부모 그래프로 이동
    )
```

### 장점과 단점

**장점:**
- ✅ **구현 단순성**: 기존 도구 사용 패턴 활용
- ✅ **표준화**: ReAct 패턴의 안정성
- ✅ **확장 용이**: 새로운 도구(에이전트) 추가 간단

**단점:**
- ❌ **도구 제약**: 도구 인터페이스의 한계
- ❌ **복잡한 상호작용**: 에이전트 간 복잡한 통신 어려움

---

## 🏢 4. Hierarchical 아키텍처

### 특징
- **계층적 구조**: 수퍼바이저의 수퍼바이저
- **팀 기반 조직**: 전문 분야별 팀 구성
- **확장성**: 대규모 시스템에 적합

### 구현 예시

```python
from typing import Literal, TypedDict
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.types import Command

model = ChatOpenAI()

# 팀별 상태 정의
class ResearchTeamState(MessagesState):
    research_focus: str
    findings: list

class ContentTeamState(MessagesState):
    content_type: str
    drafts: list

# === 연구 팀 ===
def research_supervisor(state: ResearchTeamState) -> Command[Literal["data_researcher", "academic_researcher", END]]:
    """연구팀 수퍼바이저"""
    messages = state["messages"]
    research_focus = state.get("research_focus", "general")
    
    # 연구 유형에 따라 적절한 연구원 선택
    if "데이터" in messages[-1].content or "통계" in messages[-1].content:
        return Command(goto="data_researcher")
    elif "학술" in messages[-1].content or "논문" in messages[-1].content:
        return Command(goto="academic_researcher")
    else:
        return Command(goto=END)

def data_researcher(state: ResearchTeamState) -> Command[Literal["research_supervisor"]]:
    """데이터 연구 전문가"""
    response = model.invoke([
        {"role": "system", "content": "당신은 데이터 분석 및 통계 전문가입니다."},
        {"role": "user", "content": state["messages"][-1].content}
    ])
    
    return Command(
        goto="research_supervisor",
        update={
            "messages": [response],
            "findings": state.get("findings", []) + [{"type": "data", "content": response.content}]
        }
    )

def academic_researcher(state: ResearchTeamState) -> Command[Literal["research_supervisor"]]:
    """학술 연구 전문가"""
    response = model.invoke([
        {"role": "system", "content": "당신은 학술 연구 및 문헌 조사 전문가입니다."},
        {"role": "user", "content": state["messages"][-1].content}
    ])
    
    return Command(
        goto="research_supervisor",
        update={
            "messages": [response],
            "findings": state.get("findings", []) + [{"type": "academic", "content": response.content}]
        }
    )

# 연구팀 그래프 구성
research_team_builder = StateGraph(ResearchTeamState)
research_team_builder.add_node("research_supervisor", research_supervisor)
research_team_builder.add_node("data_researcher", data_researcher)
research_team_builder.add_node("academic_researcher", academic_researcher)
research_team_builder.add_edge(START, "research_supervisor")
research_team = research_team_builder.compile()

# === 콘텐츠 팀 ===
def content_supervisor(state: ContentTeamState) -> Command[Literal["copywriter", "technical_writer", END]]:
    """콘텐츠팀 수퍼바이저"""
    messages = state["messages"]
    
    if "기술" in messages[-1].content or "API" in messages[-1].content:
        return Command(goto="technical_writer")
    else:
        return Command(goto="copywriter")

def copywriter(state: ContentTeamState) -> Command[Literal["content_supervisor"]]:
    """카피라이터"""
    response = model.invoke([
        {"role": "system", "content": "당신은 마케팅 카피라이팅 전문가입니다."},
        {"role": "user", "content": state["messages"][-1].content}
    ])
    
    return Command(
        goto="content_supervisor",
        update={
            "messages": [response],
            "drafts": state.get("drafts", []) + [{"type": "marketing", "content": response.content}]
        }
    )

def technical_writer(state: ContentTeamState) -> Command[Literal["content_supervisor"]]:
    """기술 문서 작성자"""
    response = model.invoke([
        {"role": "system", "content": "당신은 기술 문서 작성 전문가입니다."},
        {"role": "user", "content": state["messages"][-1].content}
    ])
    
    return Command(
        goto="content_supervisor",
        update={
            "messages": [response],
            "drafts": state.get("drafts", []) + [{"type": "technical", "content": response.content}]
        }
    )

# 콘텐츠팀 그래프 구성
content_team_builder = StateGraph(ContentTeamState)
content_team_builder.add_node("content_supervisor", content_supervisor)
content_team_builder.add_node("copywriter", copywriter)
content_team_builder.add_node("technical_writer", technical_writer)
content_team_builder.add_edge(START, "content_supervisor")
content_team = content_team_builder.compile()

# === 최상위 수퍼바이저 ===
def top_level_supervisor(state: MessagesState) -> Command[Literal["research_team", "content_team", END]]:
    """최상위 조정자"""
    messages = state["messages"]
    
    # 요청 유형에 따라 적절한 팀 선택
    if any(keyword in messages[-1].content for keyword in ["연구", "조사", "분석", "데이터"]):
        return Command(goto="research_team")
    elif any(keyword in messages[-1].content for keyword in ["작성", "글쓰기", "콘텐츠"]):
        return Command(goto="content_team")
    else:
        return Command(goto=END)

# 최상위 그래프 구성
top_builder = StateGraph(MessagesState)
top_builder.add_node("top_level_supervisor", top_level_supervisor)
top_builder.add_node("research_team", research_team)
top_builder.add_node("content_team", content_team)

top_builder.add_edge(START, "top_level_supervisor")
top_builder.add_edge("research_team", "top_level_supervisor")
top_builder.add_edge("content_team", "top_level_supervisor")

hierarchical_system = top_builder.compile()
```

### 장점과 단점

**장점:**
- ✅ **확장성**: 대규모 시스템에 최적
- ✅ **조직성**: 명확한 책임 분담
- ✅ **전문성**: 세분화된 전문 영역

**단점:**
- ❌ **복잡성**: 구현과 관리가 복잡
- ❌ **오버헤드**: 다층 구조로 인한 지연
- ❌ **통신 비용**: 계층 간 통신 비용 증가

---

## 🔄 5. Custom Multi-Agent Workflow

### 특징
- **명시적 제어 흐름**: 미리 정의된 워크플로우
- **조건부 분기**: 상황에 따른 동적 경로 선택
- **하이브리드 접근**: 정적 + 동적 요소 결합

---

## 🤝 Handoffs와 Communication

### Handoff 기본 개념

**Handoff는 한 에이전트가 다른 에이전트에게 제어권을 넘기는 메커니즘이다.**

#### 기본 Handoff 구조
```python
from langgraph.types import Command

def agent_with_handoff(state):
    # 작업 수행
    result = perform_task(state)
    
    # 다음 에이전트 결정
    next_agent = decide_next_agent(result)
    
    return Command(
        goto=next_agent,           # 목적지
        update={"key": "value"},   # 상태 업데이트
        graph=Command.PARENT       # 그래프 지정 (옵션)
    )
```

#### Tool로서의 Handoff
```python
from langchain_core.tools import tool

@tool
def transfer_to_specialist(specialist_type: str, context: str = "") -> Command:
    """전문가에게 작업 이양
    
    Args:
        specialist_type: 전문가 유형
        context: 전달할 컨텍스트
    """
    return Command(
        goto=f"{specialist_type}_agent",
        update={
            "transfer_context": context,
            "transfer_time": time.time()
        },
        graph=Command.PARENT
    )
```

### 메시지 표현 전략

#### 1. 에이전트 이름 포함
```python
def named_agent_response(state, agent_name: str):
    """에이전트 이름이 포함된 응답"""
    response = model.invoke(state["messages"])
    
    # OpenAI의 name 파라미터 활용
    return {
        "messages": [AIMessage(
            content=response.content,
            name=agent_name  # 에이전트 이름 명시
        )]
    }
```

#### 2. 콘텐츠에 에이전트 정보 포함
```python
def tagged_agent_response(state, agent_name: str):
    """태그가 포함된 응답"""
    response = model.invoke(state["messages"])
    
    tagged_content = f"<agent>{agent_name}</agent><message>{response.content}</message>"
    
    return {"messages": [AIMessage(content=tagged_content)]}
```

#### 3. Handoff 메시지 처리
```python
def handle_handoff_message(handoff_message: str) -> str:
    """Handoff 도구 메시지 처리"""
    # 옵션 1: 확인 메시지 추가
    tool_message = ToolMessage(
        content=f"Successfully transferred to {handoff_message}",
        tool_call_id="transfer_123"
    )
    
    # 옵션 2: AI 메시지 제거 (tool call 포함)
    # filtered_messages = [msg for msg in messages if not (
    #     isinstance(msg, AIMessage) and msg.tool_calls
    # )]
    
    return tool_message
```

---

## 🗂️ State 관리 전략

### 1. 공유 메시지 리스트

#### 전체 사고 과정 공유
```python
class FullThoughtState(MessagesState):
    """모든 에이전트의 사고 과정을 공유"""
    agent_thoughts: list[dict]  # 각 에이전트의 상세 사고 과정

def thinking_agent(state: FullThoughtState):
    """사고 과정을 기록하는 에이전트"""
    # 내부 추론 과정
    internal_thoughts = [
        "사용자 질문 분석: ...",
        "관련 정보 검색: ...", 
        "답변 구성: ..."
    ]
    
    final_response = model.invoke(state["messages"])
    
    return {
        "messages": [final_response],
        "agent_thoughts": state.get("agent_thoughts", []) + [{
            "agent": "thinking_agent",
            "thoughts": internal_thoughts,
            "final_output": final_response.content
        }]
    }
```

#### 최종 결과만 공유
```python
class ResultOnlyState(MessagesState):
    """최종 결과만 공유하는 상태"""
    private_workspaces: dict  # 에이전트별 개인 작업공간

def private_agent(state: ResultOnlyState):
    """개인 작업공간을 가진 에이전트"""
    agent_name = "private_agent"
    
    # 개인 작업공간에서 작업
    workspace = state.get("private_workspaces", {}).get(agent_name, {})
    
    # 내부 작업 (외부에 노출되지 않음)
    internal_analysis = perform_internal_analysis(state["messages"])
    workspace["analysis_history"] = workspace.get("analysis_history", []) + [internal_analysis]
    
    # 최종 결과만 공유
    final_result = generate_final_answer(internal_analysis)
    
    return {
        "messages": [AIMessage(content=final_result)],
        "private_workspaces": {
            **state.get("private_workspaces", {}),
            agent_name: workspace
        }
    }
```

### 2. 에이전트별 상태 스키마

#### 서브그래프 활용
```python
from typing import TypedDict

class AnalysisState(TypedDict):
    """분석 전용 상태"""
    raw_data: list
    analysis_result: dict
    confidence_score: float

class WritingState(TypedDict):
    """작성 전용 상태"""
    outline: str
    draft: str
    style_guide: dict

def create_specialized_subgraph():
    """전문화된 서브그래프"""
    
    def analysis_node(state: AnalysisState):
        # 분석 전용 로직
        result = analyze_data(state["raw_data"])
        return {
            "analysis_result": result,
            "confidence_score": calculate_confidence(result)
        }
    
    def writing_node(state: WritingState):
        # 작성 전용 로직
        draft = write_content(state["outline"], state["style_guide"])
        return {"draft": draft}
    
    # 각각 별도의 상태 스키마 사용
    analysis_graph = StateGraph(AnalysisState)
    writing_graph = StateGraph(WritingState)
    
    return analysis_graph, writing_graph
```

### 3. 메시지 필터링

```python
def filter_messages_for_agent(messages: list, agent_name: str) -> list:
    """특정 에이전트를 위한 메시지 필터링"""
    filtered = []
    
    for message in messages:
        # 시스템 메시지는 항상 포함
        if isinstance(message, SystemMessage):
            filtered.append(message)
        
        # 자신의 메시지와 사용자 메시지만 포함
        elif isinstance(message, (HumanMessage, AIMessage)):
            if hasattr(message, 'name') and message.name == agent_name:
                filtered.append(message)
            elif isinstance(message, HumanMessage):
                filtered.append(message)
        
        # 다른 에이전트의 도구 호출은 제외
        elif isinstance(message, AIMessage) and message.tool_calls:
            relevant_calls = [
                call for call in message.tool_calls 
                if call.get("function", {}).get("name", "").startswith(agent_name)
            ]
            if relevant_calls:
                filtered.append(AIMessage(
                    content=message.content,
                    tool_calls=relevant_calls
                ))
    
    return filtered
```

---

## 🎯 실전 설계 가이드

### 1. 아키텍처 선택 결정 트리

```python
def choose_architecture(requirements: dict) -> str:
    """요구사항에 따른 아키텍처 선택"""
    
    # 에이전트 수
    agent_count = requirements.get("agent_count", 0)
    
    # 복잡도
    complexity = requirements.get("complexity", "low")  # low, medium, high
    
    # 제어 필요성
    control_needed = requirements.get("control_needed", False)
    
    # 확장성 요구
    scalability = requirements.get("scalability", "low")  # low, medium, high
    
    if agent_count <= 3 and complexity == "low":
        return "Custom Workflow"
    
    elif agent_count <= 5 and control_needed:
        return "Supervisor"
    
    elif agent_count <= 5 and not control_needed:
        return "Supervisor (Tool-calling)"
    
    elif agent_count > 5 and scalability == "high":
        return "Hierarchical"
    
    elif complexity == "high" and not control_needed:
        return "Network"
    
    else:
        return "Supervisor"
```

### 2. 단계별 구현 전략

#### Phase 1: 프로토타입
```python
# 1단계: 가장 간단한 형태로 시작
def simple_prototype():
    """간단한 프로토타입"""
    
    @tool
    def research_tool(query: str) -> str:
        return f"Research result for: {query}"
    
    @tool  
    def write_tool(content: str) -> str:
        return f"Written content based on: {content}"
    
    tools = [research_tool, write_tool]
    supervisor = create_react_agent(model, tools)
    
    return supervisor
```

#### Phase 2: 전문화
```python
# 2단계: 에이전트 전문화
def specialized_agents():
    """전문화된 에이전트들"""
    
    def research_agent(state):
        # 연구 전문 로직
        pass
    
    def writing_agent(state):
        # 작성 전문 로직
        pass
    
    # Supervisor 패턴 적용
    return build_supervisor_system([research_agent, writing_agent])
```

#### Phase 3: 확장
```python
# 3단계: 시스템 확장
def scaled_system():
    """확장된 시스템"""
    
    # 팀별 서브시스템
    research_team = build_research_team()
    content_team = build_content_team()
    review_team = build_review_team()
    
    # 계층적 구조
    return build_hierarchical_system([research_team, content_team, review_team])
```

### 3. 성능 최적화

#### 병렬 처리 최적화
```python
from langgraph.constants import Send

def optimized_parallel_processing(state):
    """최적화된 병렬 처리"""
    tasks = state["pending_tasks"]
    
    # 작업 타입별 그룹화
    task_groups = group_tasks_by_type(tasks)
    
    # 각 그룹별로 최적의 에이전트에게 할당
    parallel_sends = []
    for task_type, task_list in task_groups.items():
        optimal_agent = select_optimal_agent(task_type, task_list)
        parallel_sends.append(
            Send(optimal_agent, {"tasks": task_list})
        )
    
    return parallel_sends

def select_optimal_agent(task_type: str, tasks: list) -> str:
    """작업 유형과 부하에 따른 최적 에이전트 선택"""
    available_agents = get_available_agents(task_type)
    
    # 부하 분산 고려
    least_loaded = min(available_agents, key=lambda a: get_agent_load(a))
    
    return least_loaded
```

#### 메모리 관리
```python
def memory_efficient_state(state: MessagesState) -> MessagesState:
    """메모리 효율적인 상태 관리"""
    messages = state["messages"]
    
    # 중요한 메시지만 유지
    important_messages = []
    
    # 시스템 메시지는 항상 유지
    system_messages = [m for m in messages if isinstance(m, SystemMessage)]
    
    # 최근 N개 메시지 유지
    recent_messages = messages[-10:]
    
    # 중요한 결정점 메시지 유지
    decision_messages = [
        m for m in messages 
        if "결정" in m.content or "선택" in m.content
    ]
    
    # 중복 제거하면서 합치기
    seen = set()
    for msg in system_messages + decision_messages + recent_messages:
        msg_id = id(msg)
        if msg_id not in seen:
            important_messages.append(msg)
            seen.add(msg_id)
    
    return {"messages": important_messages}
```

---

## 📋 패턴 선택 가이드

### 상황별 권장 패턴

| 상황 | 권장 패턴 | 이유 |
|------|-----------|------|
| **시작 단계 (3개 이하 에이전트)** | Supervisor (Tool-calling) | 구현 단순, 빠른 개발 |
| **중간 규모 (3-7개 에이전트)** | Supervisor | 명확한 제어, 확장 용이 |
| **대규모 (7개 이상 에이전트)** | Hierarchical | 조직적 관리, 확장성 |
| **동등한 협력이 필요한 경우** | Network | 유연한 상호작용 |
| **정해진 순서가 있는 경우** | Custom Workflow | 예측 가능한 실행 |

### 복잡도별 선택

#### 낮은 복잡도
```python
# Tool-calling 방식으로 시작
tools = [agent_1_tool, agent_2_tool, agent_3_tool]
simple_system = create_react_agent(model, tools)
```

#### 중간 복잡도
```python
# Supervisor 패턴 적용
def build_supervisor_system():
    builder = StateGraph(MessagesState)
    builder.add_node("supervisor", supervisor_node)
    builder.add_node("agent_1", agent_1_node)
    builder.add_node("agent_2", agent_2_node)
    # ... 에지 구성
    return builder.compile()
```

#### 높은 복잡도
```python
# Hierarchical 또는 Network 패턴
def build_complex_system():
    # 팀별 서브시스템 구성
    team_graphs = create_team_graphs()
    
    # 최상위 조정자
    top_level = create_top_level_supervisor(team_graphs)
    
    return top_level
```

---

## ✅ 베스트 프랙티스

### 1. 설계 원칙

#### 단일 책임 원칙
```python
# ✅ 좋은 예: 명확한 단일 책임
def research_agent(state):
    """오직 정보 수집만 담당"""
    query = extract_query(state)
    research_result = perform_research(query)
    return {"research_result": research_result}

# ❌ 나쁜 예: 여러 책임이 섞임
def multi_purpose_agent(state):
    """연구, 작성, 검토를 모두 수행"""
    research = perform_research(state)
    content = write_content(research)
    review = review_content(content)
    return {"final_result": review}
```

#### 명확한 인터페이스
```python
# ✅ 명확한 에이전트 인터페이스
class AgentInterface:
    def process(self, input_data: dict) -> dict:
        """표준 처리 인터페이스"""
        pass
    
    def get_capabilities(self) -> list:
        """에이전트 역량 정보"""
        pass
    
    def get_status(self) -> dict:
        """현재 상태 정보"""
        pass
```

### 2. 에러 처리 및 복구

```python
def robust_agent(state):
    """견고한 에러 처리가 포함된 에이전트"""
    try:
        result = perform_main_task(state)
        return {"result": result, "status": "success"}
    
    except SpecificError as e:
        # 특정 에러에 대한 복구 시도
        fallback_result = perform_fallback_task(state)
        return {
            "result": fallback_result, 
            "status": "fallback",
            "error": str(e)
        }
    
    except Exception as e:
        # 일반 에러 처리
        return {
            "status": "error",
            "error": str(e),
            "needs_human_intervention": True
        }

def error_recovery_supervisor(state):
    """에러 복구 수퍼바이저"""
    last_result = state.get("last_result", {})
    
    if last_result.get("status") == "error":
        if last_result.get("needs_human_intervention"):
            return Command(goto="human_review_agent")
        else:
            return Command(goto="retry_agent")
    
    return Command(goto="next_normal_agent")
```

### 3. 모니터링 및 로깅

```python
import logging
from datetime import datetime

def monitored_agent(state, agent_name: str):
    """모니터링이 포함된 에이전트"""
    start_time = datetime.now()
    
    logging.info(f"[{agent_name}] 시작: {start_time}")
    logging.debug(f"[{agent_name}] 입력 상태: {state}")
    
    try:
        result = perform_agent_task(state)
        
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        logging.info(f"[{agent_name}] 완료: {duration:.2f}초")
        logging.debug(f"[{agent_name}] 출력 결과: {result}")
        
        # 성능 메트릭 기록
        record_performance_metric(agent_name, duration, "success")
        
        return result
    
    except Exception as e:
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        logging.error(f"[{agent_name}] 에러 ({duration:.2f}초): {str(e)}")
        record_performance_metric(agent_name, duration, "error")
        
        raise

def record_performance_metric(agent_name: str, duration: float, status: str):
    """성능 메트릭 기록"""
    # 실제로는 모니터링 시스템에 전송
    print(f"Metric: {agent_name} - {duration:.2f}s - {status}")
```

### 4. 테스트 전략

```python
import pytest
from unittest.mock import Mock

class TestMultiAgentSystem:
    
    def test_supervisor_routing(self):
        """수퍼바이저 라우팅 테스트"""
        # Given
        mock_state = {"messages": [HumanMessage("연구 요청")]}
        
        # When
        result = supervisor(mock_state)
        
        # Then
        assert result.goto == "research_agent"
    
    def test_agent_handoff(self):
        """에이전트 간 handoff 테스트"""
        # Given
        initial_state = {"messages": [HumanMessage("test")]}
        
        # When
        result = research_agent(initial_state)
        
        # Then
        assert "research_result" in result
        assert result["goto"] == "writing_agent"
    
    def test_error_handling(self):
        """에러 처리 테스트"""
        # Given
        error_state = {"messages": [], "force_error": True}
        
        # When & Then
        with pytest.raises(SpecificError):
            faulty_agent(error_state)
    
    @pytest.mark.integration
    def test_end_to_end_workflow(self):
        """전체 워크플로우 통합 테스트"""
        # Given
        system = build_multi_agent_system()
        initial_input = {"messages": [HumanMessage("복잡한 작업 요청")]}
        
        # When
        final_result = system.invoke(initial_input)
        
        # Then
        assert final_result["status"] == "completed"
        assert len(final_result["messages"]) > 0
```

---

## 🎉 결론

Multi-Agent 시스템은 복잡한 AI 애플리케이션을 구축하기 위한 강력한 아키텍처 패턴이다.

### 🎯 핵심 원칙

1. **단순함에서 시작**: 가장 간단한 패턴부터 시작하여 점진적 확장
2. **명확한 책임 분담**: 각 에이전트의 역할과 책임을 명확히 정의
3. **효율적인 통신**: 에이전트 간 통신 방식과 상태 관리 전략 수립
4. **견고한 에러 처리**: 실패 상황에 대한 복구 메커니즘 구현

### 🚀 선택 가이드

| 프로젝트 단계 | 권장 시작점 | 확장 방향 |
|---------------|-------------|-----------|
| **프로토타입** | Supervisor (Tool-calling) | → Supervisor |
| **MVP** | Supervisor | → Hierarchical |
| **프로덕션** | Hierarchical | → Custom Hybrid |

### 💡 실무 팁

- **시작은 단순하게**: Tool-calling 방식으로 시작
- **점진적 확장**: 필요에 따라 복잡도 증가
- **모니터링 필수**: 에이전트 성능과 상호작용 추적
- **테스트 자동화**: 각 패턴별 테스트 전략 수립

> **Multi-Agent 시스템의 진정한 가치는 각 에이전트의 전문성을 최대한 활용하면서도 전체 시스템의 일관성을 유지하는 데 있다.**

---

## 📚 참고 자료

- [LangGraph Multi-Agent Systems](https://langchain-ai.github.io/langgraph/concepts/multi_agent/)
- [Multi-Agent Collaboration Tutorial](https://langchain-ai.github.io/langgraph/tutorials/multi_agent/multi-agent-collaboration/)
- [Agent Supervisor Tutorial](https://langchain-ai.github.io/langgraph/tutorials/multi_agent/agent_supervisor/)
- [Hierarchical Agent Teams](https://langchain-ai.github.io/langgraph/tutorials/multi_agent/hierarchical_agent_teams/)
- [LangGraph Command Documentation](https://langchain-ai.github.io/langgraph/reference/types/#command)

---