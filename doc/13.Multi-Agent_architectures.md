# ğŸ¤– LangGraph Multi-Agent ë””ìì¸ íŒ¨í„´ ì™„ì „ ê°€ì´ë“œ

> ë³µì¡í•œ AI ì‹œìŠ¤í…œì„ ìœ„í•œ ë‹¤ì–‘í•œ ë©€í‹° ì—ì´ì „íŠ¸ ì•„í‚¤í…ì²˜ íŒ¨í„´ê³¼ ì„¤ê³„ ì „ëµ

## ğŸ“š ëª©ì°¨

- [Multi-Agent ì‹œìŠ¤í…œ ê°œìš”](#-multi-agent-ì‹œìŠ¤í…œ-ê°œìš”)
- [ì•„í‚¤í…ì²˜ íŒ¨í„´ ê°œìš”](#-ì•„í‚¤í…ì²˜-íŒ¨í„´-ê°œìš”)
- [1. Network ì•„í‚¤í…ì²˜](#ï¸-1-network-ì•„í‚¤í…ì²˜)
- [2. Supervisor ì•„í‚¤í…ì²˜](#-2-supervisor-ì•„í‚¤í…ì²˜)
- [3. Supervisor (Tool-calling) ì•„í‚¤í…ì²˜](#ï¸-3-supervisor-tool-calling-ì•„í‚¤í…ì²˜)
- [4. Hierarchical ì•„í‚¤í…ì²˜](#-4-hierarchical-ì•„í‚¤í…ì²˜)
- [5. Custom Multi-Agent Workflow](#-5-custom-multi-agent-workflow)
- [Handoffsì™€ Communication](#-handoffsì™€-communication)
- [State ê´€ë¦¬ ì „ëµ](#ï¸-state-ê´€ë¦¬-ì „ëµ)
- [ì‹¤ì „ ì„¤ê³„ ê°€ì´ë“œ](#-ì‹¤ì „-ì„¤ê³„-ê°€ì´ë“œ)
- [íŒ¨í„´ ì„ íƒ ê°€ì´ë“œ](#-íŒ¨í„´-ì„ íƒ-ê°€ì´ë“œ)
- [ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤](#-ë² ìŠ¤íŠ¸-í”„ë™í‹°ìŠ¤)
- [ê²°ë¡ ](#-ê²°ë¡ )

---

## ğŸ¯ Multi-Agent ì‹œìŠ¤í…œ ê°œìš”

### ì •ì˜
**Multi-Agent ì‹œìŠ¤í…œì€ ì—¬ëŸ¬ ê°œì˜ ë…ë¦½ì ì¸ ì—ì´ì „íŠ¸ë“¤ì´ í˜‘ë ¥í•˜ì—¬ ë³µì¡í•œ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” AI ì•„í‚¤í…ì²˜ë‹¤.**

### ì–¸ì œ Multi-Agentê°€ í•„ìš”í•œê°€?

#### ë‹¨ì¼ Agentì˜ í•œê³„
- âŒ **ë„êµ¬ ê³¼ë¶€í•˜**: ë„ˆë¬´ ë§ì€ ë„êµ¬ë¡œ ì¸í•œ ì˜ëª»ëœ ì„ íƒ
- âŒ **ì»¨í…ìŠ¤íŠ¸ ë³µì¡ì„±**: ë‹¨ì¼ ì—ì´ì „íŠ¸ê°€ ì¶”ì í•˜ê¸° ì–´ë ¤ìš´ ë³µì¡í•œ ìƒí™©
- âŒ **ì „ë¬¸ì„± ë¶€ì¡±**: ì—¬ëŸ¬ ì „ë¬¸ ë¶„ì•¼ë¥¼ í•˜ë‚˜ì˜ ì—ì´ì „íŠ¸ê°€ ì²˜ë¦¬í•˜ê¸° ì–´ë ¤ì›€

#### Multi-Agentì˜ ì´ì 
- âœ… **ëª¨ë“ˆì„±**: ê°œë°œ, í…ŒìŠ¤íŠ¸, ìœ ì§€ë³´ìˆ˜ ìš©ì´ì„±
- âœ… **ì „ë¬¸í™”**: ë„ë©”ì¸ë³„ ì „ë¬¸ ì—ì´ì „íŠ¸ë¡œ ì„±ëŠ¥ í–¥ìƒ
- âœ… **ì œì–´**: ì—ì´ì „íŠ¸ ê°„ ëª…ì‹œì  í†µì‹  ì œì–´ ê°€ëŠ¥

---

## ğŸ“Š ì•„í‚¤í…ì²˜ íŒ¨í„´ ê°œìš”

![image](../src/imgs/architectures.png)

| íŒ¨í„´ | ë³µì¡ë„ | ì œì–´ ë°©ì‹ | í™•ì¥ì„± | ì£¼ìš” ì‚¬ìš© ì‚¬ë¡€ |
|------|--------|-----------|--------|---------------|
| **Network** | ë†’ìŒ | ë¶„ì‚°í˜• | ì¤‘ê°„ | ë™ë“±í•œ ì—ì´ì „íŠ¸ë“¤ì˜ í˜‘ë ¥ |
| **Supervisor** | ì¤‘ê°„ | ì¤‘ì•™ì§‘ì¤‘í˜• | ë†’ìŒ | ëª…í™•í•œ ì—­í•  ë¶„ë‹´ |
| **Supervisor (Tool-calling)** | ë‚®ìŒ | ì¤‘ì•™ì§‘ì¤‘í˜• | ë†’ìŒ | ê°„ë‹¨í•œ ì—ì´ì „íŠ¸ ì¡°ì • |
| **Hierarchical** | ë†’ìŒ | ê³„ì¸µí˜• | ë§¤ìš° ë†’ìŒ | ëŒ€ê·œëª¨ ë³µì¡í•œ ì‹œìŠ¤í…œ |
| **Custom Workflow** | ë‹¤ì–‘ | í˜¼í•©í˜• | ì¤‘ê°„ | íŠ¹ì • ì›Œí¬í”Œë¡œìš° |

---

## ğŸ•¸ï¸ 1. Network ì•„í‚¤í…ì²˜

### íŠ¹ì§•
- **Many-to-Many ì—°ê²°**: ëª¨ë“  ì—ì´ì „íŠ¸ê°€ ì„œë¡œ ì§ì ‘ í†µì‹  ê°€ëŠ¥
- **ë¶„ì‚° ì˜ì‚¬ê²°ì •**: ê° ì—ì´ì „íŠ¸ê°€ ë‹¤ìŒ í˜¸ì¶œí•  ì—ì´ì „íŠ¸ ê²°ì •
- **ë¹„ê³„ì¸µì **: ëª…í™•í•œ ìƒí•˜ ê´€ê³„ ì—†ìŒ

### êµ¬í˜„ ì˜ˆì‹œ

```python
from typing import Literal
from langchain_openai import ChatOpenAI
from langgraph.types import Command
from langgraph.graph import StateGraph, MessagesState, START, END

model = ChatOpenAI()

def researcher_agent(state: MessagesState) -> Command[Literal["writer_agent", "reviewer_agent", END]]:
    """ì—°êµ¬ ì „ë‹´ ì—ì´ì „íŠ¸"""
    messages = state["messages"]
    
    # ì—°êµ¬ ì‘ì—… ìˆ˜í–‰
    research_prompt = f"ë‹¤ìŒ ì£¼ì œì— ëŒ€í•´ ì—°êµ¬í•˜ì„¸ìš”: {messages[-1].content}"
    response = model.invoke([{"role": "system", "content": "ë‹¹ì‹ ì€ ì „ë¬¸ ì—°êµ¬ì›ì…ë‹ˆë‹¤."}, 
                           {"role": "user", "content": research_prompt}])
    
    # ë‹¤ìŒ ì—ì´ì „íŠ¸ ê²°ì •
    if "ì‘ì„±" in response.content:
        next_agent = "writer_agent"
    elif "ê²€í† " in response.content:
        next_agent = "reviewer_agent"
    else:
        next_agent = END
    
    return Command(
        goto=next_agent,
        update={"messages": [response]}
    )

def writer_agent(state: MessagesState) -> Command[Literal["researcher_agent", "reviewer_agent", END]]:
    """ì‘ì„± ì „ë‹´ ì—ì´ì „íŠ¸"""
    messages = state["messages"]
    
    # ì‘ì„± ì‘ì—… ìˆ˜í–‰
    writing_prompt = f"ë‹¤ìŒ ì—°êµ¬ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”: {messages[-1].content}"
    response = model.invoke([{"role": "system", "content": "ë‹¹ì‹ ì€ ì „ë¬¸ ì‘ê°€ì…ë‹ˆë‹¤."}, 
                           {"role": "user", "content": writing_prompt}])
    
    # ë‹¤ìŒ ì—ì´ì „íŠ¸ ê²°ì • ë¡œì§
    if "ì¶”ê°€ ì—°êµ¬" in response.content:
        next_agent = "researcher_agent"
    elif "ê²€í† " in response.content:
        next_agent = "reviewer_agent"
    else:
        next_agent = END
    
    return Command(
        goto=next_agent,
        update={"messages": [response]}
    )

def reviewer_agent(state: MessagesState) -> Command[Literal["researcher_agent", "writer_agent", END]]:
    """ê²€í†  ì „ë‹´ ì—ì´ì „íŠ¸"""
    messages = state["messages"]
    
    # ê²€í†  ì‘ì—… ìˆ˜í–‰
    review_prompt = f"ë‹¤ìŒ ë‚´ìš©ì„ ê²€í† í•˜ì„¸ìš”: {messages[-1].content}"
    response = model.invoke([{"role": "system", "content": "ë‹¹ì‹ ì€ ì „ë¬¸ ê²€í† ìì…ë‹ˆë‹¤."}, 
                           {"role": "user", "content": review_prompt}])
    
    # ë‹¤ìŒ ì—ì´ì „íŠ¸ ê²°ì • ë¡œì§
    if "ìˆ˜ì • í•„ìš”" in response.content:
        next_agent = "writer_agent"
    elif "ì¶”ê°€ ì •ë³´" in response.content:
        next_agent = "researcher_agent"
    else:
        next_agent = END
    
    return Command(
        goto=next_agent,
        update={"messages": [response]}
    )

# ë„¤íŠ¸ì›Œí¬ ê·¸ë˜í”„ êµ¬ì„±
builder = StateGraph(MessagesState)
builder.add_node("researcher_agent", researcher_agent)
builder.add_node("writer_agent", writer_agent)
builder.add_node("reviewer_agent", reviewer_agent)
builder.add_edge(START, "researcher_agent")

network = builder.compile()
```

### ì¥ì ê³¼ ë‹¨ì 

**ì¥ì :**
- âœ… **ìœ ì—°ì„±**: ë™ì ì¸ ìƒí™©ì— ì ì‘ì  ëŒ€ì‘
- âœ… **ììœ¨ì„±**: ê° ì—ì´ì „íŠ¸ì˜ ë…ë¦½ì  íŒë‹¨

**ë‹¨ì :**
- âŒ **ë³µì¡ì„±**: ì˜ˆì¸¡í•˜ê¸° ì–´ë ¤ìš´ ì‹¤í–‰ ê²½ë¡œ
- âŒ **ë¬´í•œ ë£¨í”„ ìœ„í—˜**: ì—ì´ì „íŠ¸ ê°„ ìˆœí™˜ í˜¸ì¶œ ê°€ëŠ¥ì„±

### ì ìš© ì‚¬ë¡€
- ë¸Œë ˆì¸ìŠ¤í† ë° ì‹œìŠ¤í…œ
- ì°½ì˜ì  ë¬¸ì œ í•´ê²°
- ë™ë“±í•œ ì „ë¬¸ê°€ë“¤ì˜ í˜‘ë ¥

---

## ğŸ‘¨â€ğŸ’¼ 2. Supervisor ì•„í‚¤í…ì²˜

### íŠ¹ì§•
- **ì¤‘ì•™ì§‘ì¤‘ì‹ ì œì–´**: ìˆ˜í¼ë°”ì´ì €ê°€ ëª¨ë“  ë¼ìš°íŒ… ê²°ì •
- **ë‹¨ë°©í–¥ í†µì‹ **: ì—ì´ì „íŠ¸ë“¤ì€ ìˆ˜í¼ë°”ì´ì €ë¥¼ í†µí•´ì„œë§Œ í†µì‹ 
- **ëª…í™•í•œ ì œì–´**: ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì‹¤í–‰ íë¦„

### êµ¬í˜„ ì˜ˆì‹œ

```python
from typing import Literal
from langchain_openai import ChatOpenAI
from langgraph.types import Command
from langgraph.graph import StateGraph, MessagesState, START, END

model = ChatOpenAI()

def supervisor(state: MessagesState) -> Command[Literal["research_agent", "writing_agent", "review_agent", END]]:
    """ì¤‘ì•™ ì¡°ì •ì"""
    messages = state["messages"]
    
    # êµ¬ì¡°í™”ëœ ì¶œë ¥ìœ¼ë¡œ ë‹¤ìŒ ì—ì´ì „íŠ¸ ê²°ì •
    routing_prompt = f"""
    í˜„ì¬ ëŒ€í™” ìƒí™©ì„ ë¶„ì„í•˜ê³  ë‹¤ìŒ ì¤‘ ì ì ˆí•œ ì—ì´ì „íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”:
    - research_agent: ì •ë³´ ìˆ˜ì§‘ì´ í•„ìš”í•œ ê²½ìš°
    - writing_agent: ì½˜í…ì¸  ì‘ì„±ì´ í•„ìš”í•œ ê²½ìš°  
    - review_agent: ê²€í† ê°€ í•„ìš”í•œ ê²½ìš°
    - __end__: ì‘ì—…ì´ ì™„ë£Œëœ ê²½ìš°
    
    ëŒ€í™”: {messages[-1].content}
    
    ì‘ë‹µ í˜•ì‹: {{"next_agent": "agent_name", "reason": "ì„ íƒ ì´ìœ "}}
    """
    
    response = model.invoke([
        {"role": "system", "content": "ë‹¹ì‹ ì€ ì‘ì—…ì„ ì¡°ì •í•˜ëŠ” ìˆ˜í¼ë°”ì´ì €ì…ë‹ˆë‹¤."},
        {"role": "user", "content": routing_prompt}
    ])
    
    # ì‹¤ì œë¡œëŠ” structured output ì‚¬ìš© ê¶Œì¥
    next_agent = "research_agent"  # íŒŒì‹±ëœ ê²°ê³¼
    
    return Command(goto=next_agent)

def research_agent(state: MessagesState) -> Command[Literal["supervisor"]]:
    """ì—°êµ¬ ì „ë¬¸ ì—ì´ì „íŠ¸"""
    messages = state["messages"]
    
    research_response = model.invoke([
        {"role": "system", "content": "ë‹¹ì‹ ì€ ì •ë³´ ìˆ˜ì§‘ ì „ë¬¸ê°€ì…ë‹ˆë‹¤."},
        {"role": "user", "content": f"ë‹¤ìŒì— ëŒ€í•´ ì—°êµ¬í•˜ì„¸ìš”: {messages[-1].content}"}
    ])
    
    return Command(
        goto="supervisor",
        update={"messages": [research_response]}
    )

def writing_agent(state: MessagesState) -> Command[Literal["supervisor"]]:
    """ì‘ì„± ì „ë¬¸ ì—ì´ì „íŠ¸"""
    messages = state["messages"]
    
    writing_response = model.invoke([
        {"role": "system", "content": "ë‹¹ì‹ ì€ ì½˜í…ì¸  ì‘ì„± ì „ë¬¸ê°€ì…ë‹ˆë‹¤."},
        {"role": "user", "content": f"ë‹¤ìŒì„ ë°”íƒ•ìœ¼ë¡œ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”: {messages[-1].content}"}
    ])
    
    return Command(
        goto="supervisor",
        update={"messages": [writing_response]}
    )

def review_agent(state: MessagesState) -> Command[Literal["supervisor"]]:
    """ê²€í†  ì „ë¬¸ ì—ì´ì „íŠ¸"""
    messages = state["messages"]
    
    review_response = model.invoke([
        {"role": "system", "content": "ë‹¹ì‹ ì€ í’ˆì§ˆ ê²€í†  ì „ë¬¸ê°€ì…ë‹ˆë‹¤."},
        {"role": "user", "content": f"ë‹¤ìŒì„ ê²€í† í•˜ì„¸ìš”: {messages[-1].content}"}
    ])
    
    return Command(
        goto="supervisor",
        update={"messages": [review_response]}
    )

# ìˆ˜í¼ë°”ì´ì € ê·¸ë˜í”„ êµ¬ì„±
builder = StateGraph(MessagesState)
builder.add_node("supervisor", supervisor)
builder.add_node("research_agent", research_agent)
builder.add_node("writing_agent", writing_agent)
builder.add_node("review_agent", review_agent)

builder.add_edge(START, "supervisor")
builder.add_edge("research_agent", "supervisor")
builder.add_edge("writing_agent", "supervisor")
builder.add_edge("review_agent", "supervisor")

supervisor_system = builder.compile()
```

### ë³‘ë ¬ ì²˜ë¦¬ í™•ì¥

```python
from langgraph.constants import Send

def parallel_supervisor(state: MessagesState):
    """ë³‘ë ¬ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•œ ìˆ˜í¼ë°”ì´ì €"""
    tasks = state.get("pending_tasks", [])
    
    # ì—¬ëŸ¬ ì—ì´ì „íŠ¸ì—ê²Œ ë™ì‹œì— ì‘ì—… ë¶„ë°°
    parallel_sends = []
    for task in tasks:
        if task["type"] == "research":
            parallel_sends.append(Send("research_agent", {"task": task}))
        elif task["type"] == "writing":
            parallel_sends.append(Send("writing_agent", {"task": task}))
    
    return parallel_sends
```

### ì¥ì ê³¼ ë‹¨ì 

**ì¥ì :**
- âœ… **ì˜ˆì¸¡ ê°€ëŠ¥ì„±**: ëª…í™•í•œ ì œì–´ íë¦„
- âœ… **í™•ì¥ì„±**: ìƒˆë¡œìš´ ì—ì´ì „íŠ¸ ì¶”ê°€ ìš©ì´
- âœ… **ë³‘ë ¬ ì²˜ë¦¬**: Map-Reduce íŒ¨í„´ ì ìš© ê°€ëŠ¥

**ë‹¨ì :**
- âŒ **ì¤‘ì•™ ì§‘ì¤‘**: ìˆ˜í¼ë°”ì´ì €ê°€ ë³‘ëª©ì ì´ ë  ìˆ˜ ìˆìŒ
- âŒ **ë³µì¡í•œ ë¼ìš°íŒ…**: ì—ì´ì „íŠ¸ ìˆ˜ ì¦ê°€ ì‹œ ë¼ìš°íŒ… ë¡œì§ ë³µì¡í™”

---

## ğŸ› ï¸ 3. Supervisor (Tool-calling) ì•„í‚¤í…ì²˜

### íŠ¹ì§•
- **ë„êµ¬ë¡œì„œì˜ ì—ì´ì „íŠ¸**: ê° ì—ì´ì „íŠ¸ê°€ ë„êµ¬ë¡œ í‘œí˜„ë¨
- **í‘œì¤€ ReAct íŒ¨í„´**: ìˆ˜í¼ë°”ì´ì €ê°€ ì¼ë°˜ì ì¸ tool-calling ì—ì´ì „íŠ¸
- **ê°„ë‹¨í•œ êµ¬í˜„**: ê¸°ì¡´ ë„êµ¬ ì‚¬ìš© íŒ¨í„´ í™œìš©

### êµ¬í˜„ ì˜ˆì‹œ

```python
from typing import Annotated
from langchain_core.tools import tool
from langchain_openai import ChatOpenAI
from langgraph.prebuilt import InjectedState, create_react_agent

model = ChatOpenAI()

@tool
def research_agent(
    query: str,
    state: Annotated[dict, InjectedState]
) -> str:
    """ì •ë³´ë¥¼ ì—°êµ¬í•˜ê³  ìˆ˜ì§‘í•˜ëŠ” ì—ì´ì „íŠ¸
    
    Args:
        query: ì—°êµ¬í•  ì£¼ì œë‚˜ ì§ˆë¬¸
        state: í˜„ì¬ ëŒ€í™” ìƒíƒœ
    """
    messages = state.get("messages", [])
    
    research_response = model.invoke([
        {"role": "system", "content": "ë‹¹ì‹ ì€ ì •ë³´ ìˆ˜ì§‘ ì „ë¬¸ê°€ì…ë‹ˆë‹¤."},
        {"role": "user", "content": f"ë‹¤ìŒì— ëŒ€í•´ ì—°êµ¬í•˜ì„¸ìš”: {query}"}
    ])
    
    return research_response.content

@tool
def writing_agent(
    content: str,
    style: str = "professional",
    state: Annotated[dict, InjectedState] = None
) -> str:
    """ì½˜í…ì¸ ë¥¼ ì‘ì„±í•˜ëŠ” ì—ì´ì „íŠ¸
    
    Args:
        content: ì‘ì„±í•  ë‚´ìš©ì˜ ê¸°ë°˜ ì •ë³´
        style: ì‘ì„± ìŠ¤íƒ€ì¼ (professional, casual, academic)
        state: í˜„ì¬ ëŒ€í™” ìƒíƒœ
    """
    writing_response = model.invoke([
        {"role": "system", "content": f"ë‹¹ì‹ ì€ {style} ìŠ¤íƒ€ì¼ì˜ ì‘ì„± ì „ë¬¸ê°€ì…ë‹ˆë‹¤."},
        {"role": "user", "content": f"ë‹¤ìŒì„ ë°”íƒ•ìœ¼ë¡œ ê¸€ì„ ì‘ì„±í•˜ì„¸ìš”: {content}"}
    ])
    
    return writing_response.content

@tool
def review_agent(
    content: str,
    criteria: str = "accuracy and clarity",
    state: Annotated[dict, InjectedState] = None
) -> str:
    """ì½˜í…ì¸ ë¥¼ ê²€í† í•˜ëŠ” ì—ì´ì „íŠ¸
    
    Args:
        content: ê²€í† í•  ì½˜í…ì¸ 
        criteria: ê²€í†  ê¸°ì¤€
        state: í˜„ì¬ ëŒ€í™” ìƒíƒœ
    """
    review_response = model.invoke([
        {"role": "system", "content": f"ë‹¹ì‹ ì€ {criteria} ê¸°ì¤€ìœ¼ë¡œ ê²€í† í•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤."},
        {"role": "user", "content": f"ë‹¤ìŒì„ ê²€í† í•˜ì„¸ìš”: {content}"}
    ])
    
    return review_response.content

# ë„êµ¬ ëª©ë¡
tools = [research_agent, writing_agent, review_agent]

# ìˆ˜í¼ë°”ì´ì € ì—ì´ì „íŠ¸ ìƒì„± (ì‚¬ì „ êµ¬ì¶•ëœ ReAct ì—ì´ì „íŠ¸ ì‚¬ìš©)
supervisor_agent = create_react_agent(model, tools)
```

### Handoff ë„êµ¬ íŒ¨í„´

```python
from langgraph.types import Command

@tool
def transfer_to_specialist(
    specialist_type: str,
    task_description: str,
    context: str = ""
) -> Command:
    """ì „ë¬¸ê°€ì—ê²Œ ì‘ì—…ì„ ì´ì–‘í•˜ëŠ” ë„êµ¬
    
    Args:
        specialist_type: ì „ë¬¸ê°€ ìœ í˜• (researcher, writer, reviewer)
        task_description: ì‘ì—… ì„¤ëª…
        context: ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸
    """
    return Command(
        goto=f"{specialist_type}_agent",
        update={
            "current_task": task_description,
            "context": context
        },
        graph=Command.PARENT  # ë¶€ëª¨ ê·¸ë˜í”„ë¡œ ì´ë™
    )
```

### ì¥ì ê³¼ ë‹¨ì 

**ì¥ì :**
- âœ… **êµ¬í˜„ ë‹¨ìˆœì„±**: ê¸°ì¡´ ë„êµ¬ ì‚¬ìš© íŒ¨í„´ í™œìš©
- âœ… **í‘œì¤€í™”**: ReAct íŒ¨í„´ì˜ ì•ˆì •ì„±
- âœ… **í™•ì¥ ìš©ì´**: ìƒˆë¡œìš´ ë„êµ¬(ì—ì´ì „íŠ¸) ì¶”ê°€ ê°„ë‹¨

**ë‹¨ì :**
- âŒ **ë„êµ¬ ì œì•½**: ë„êµ¬ ì¸í„°í˜ì´ìŠ¤ì˜ í•œê³„
- âŒ **ë³µì¡í•œ ìƒí˜¸ì‘ìš©**: ì—ì´ì „íŠ¸ ê°„ ë³µì¡í•œ í†µì‹  ì–´ë ¤ì›€

---

## ğŸ¢ 4. Hierarchical ì•„í‚¤í…ì²˜

### íŠ¹ì§•
- **ê³„ì¸µì  êµ¬ì¡°**: ìˆ˜í¼ë°”ì´ì €ì˜ ìˆ˜í¼ë°”ì´ì €
- **íŒ€ ê¸°ë°˜ ì¡°ì§**: ì „ë¬¸ ë¶„ì•¼ë³„ íŒ€ êµ¬ì„±
- **í™•ì¥ì„±**: ëŒ€ê·œëª¨ ì‹œìŠ¤í…œì— ì í•©

### êµ¬í˜„ ì˜ˆì‹œ

```python
from typing import Literal, TypedDict
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.types import Command

model = ChatOpenAI()

# íŒ€ë³„ ìƒíƒœ ì •ì˜
class ResearchTeamState(MessagesState):
    research_focus: str
    findings: list

class ContentTeamState(MessagesState):
    content_type: str
    drafts: list

# === ì—°êµ¬ íŒ€ ===
def research_supervisor(state: ResearchTeamState) -> Command[Literal["data_researcher", "academic_researcher", END]]:
    """ì—°êµ¬íŒ€ ìˆ˜í¼ë°”ì´ì €"""
    messages = state["messages"]
    research_focus = state.get("research_focus", "general")
    
    # ì—°êµ¬ ìœ í˜•ì— ë”°ë¼ ì ì ˆí•œ ì—°êµ¬ì› ì„ íƒ
    if "ë°ì´í„°" in messages[-1].content or "í†µê³„" in messages[-1].content:
        return Command(goto="data_researcher")
    elif "í•™ìˆ " in messages[-1].content or "ë…¼ë¬¸" in messages[-1].content:
        return Command(goto="academic_researcher")
    else:
        return Command(goto=END)

def data_researcher(state: ResearchTeamState) -> Command[Literal["research_supervisor"]]:
    """ë°ì´í„° ì—°êµ¬ ì „ë¬¸ê°€"""
    response = model.invoke([
        {"role": "system", "content": "ë‹¹ì‹ ì€ ë°ì´í„° ë¶„ì„ ë° í†µê³„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤."},
        {"role": "user", "content": state["messages"][-1].content}
    ])
    
    return Command(
        goto="research_supervisor",
        update={
            "messages": [response],
            "findings": state.get("findings", []) + [{"type": "data", "content": response.content}]
        }
    )

def academic_researcher(state: ResearchTeamState) -> Command[Literal["research_supervisor"]]:
    """í•™ìˆ  ì—°êµ¬ ì „ë¬¸ê°€"""
    response = model.invoke([
        {"role": "system", "content": "ë‹¹ì‹ ì€ í•™ìˆ  ì—°êµ¬ ë° ë¬¸í—Œ ì¡°ì‚¬ ì „ë¬¸ê°€ì…ë‹ˆë‹¤."},
        {"role": "user", "content": state["messages"][-1].content}
    ])
    
    return Command(
        goto="research_supervisor",
        update={
            "messages": [response],
            "findings": state.get("findings", []) + [{"type": "academic", "content": response.content}]
        }
    )

# ì—°êµ¬íŒ€ ê·¸ë˜í”„ êµ¬ì„±
research_team_builder = StateGraph(ResearchTeamState)
research_team_builder.add_node("research_supervisor", research_supervisor)
research_team_builder.add_node("data_researcher", data_researcher)
research_team_builder.add_node("academic_researcher", academic_researcher)
research_team_builder.add_edge(START, "research_supervisor")
research_team = research_team_builder.compile()

# === ì½˜í…ì¸  íŒ€ ===
def content_supervisor(state: ContentTeamState) -> Command[Literal["copywriter", "technical_writer", END]]:
    """ì½˜í…ì¸ íŒ€ ìˆ˜í¼ë°”ì´ì €"""
    messages = state["messages"]
    
    if "ê¸°ìˆ " in messages[-1].content or "API" in messages[-1].content:
        return Command(goto="technical_writer")
    else:
        return Command(goto="copywriter")

def copywriter(state: ContentTeamState) -> Command[Literal["content_supervisor"]]:
    """ì¹´í”¼ë¼ì´í„°"""
    response = model.invoke([
        {"role": "system", "content": "ë‹¹ì‹ ì€ ë§ˆì¼€íŒ… ì¹´í”¼ë¼ì´íŒ… ì „ë¬¸ê°€ì…ë‹ˆë‹¤."},
        {"role": "user", "content": state["messages"][-1].content}
    ])
    
    return Command(
        goto="content_supervisor",
        update={
            "messages": [response],
            "drafts": state.get("drafts", []) + [{"type": "marketing", "content": response.content}]
        }
    )

def technical_writer(state: ContentTeamState) -> Command[Literal["content_supervisor"]]:
    """ê¸°ìˆ  ë¬¸ì„œ ì‘ì„±ì"""
    response = model.invoke([
        {"role": "system", "content": "ë‹¹ì‹ ì€ ê¸°ìˆ  ë¬¸ì„œ ì‘ì„± ì „ë¬¸ê°€ì…ë‹ˆë‹¤."},
        {"role": "user", "content": state["messages"][-1].content}
    ])
    
    return Command(
        goto="content_supervisor",
        update={
            "messages": [response],
            "drafts": state.get("drafts", []) + [{"type": "technical", "content": response.content}]
        }
    )

# ì½˜í…ì¸ íŒ€ ê·¸ë˜í”„ êµ¬ì„±
content_team_builder = StateGraph(ContentTeamState)
content_team_builder.add_node("content_supervisor", content_supervisor)
content_team_builder.add_node("copywriter", copywriter)
content_team_builder.add_node("technical_writer", technical_writer)
content_team_builder.add_edge(START, "content_supervisor")
content_team = content_team_builder.compile()

# === ìµœìƒìœ„ ìˆ˜í¼ë°”ì´ì € ===
def top_level_supervisor(state: MessagesState) -> Command[Literal["research_team", "content_team", END]]:
    """ìµœìƒìœ„ ì¡°ì •ì"""
    messages = state["messages"]
    
    # ìš”ì²­ ìœ í˜•ì— ë”°ë¼ ì ì ˆí•œ íŒ€ ì„ íƒ
    if any(keyword in messages[-1].content for keyword in ["ì—°êµ¬", "ì¡°ì‚¬", "ë¶„ì„", "ë°ì´í„°"]):
        return Command(goto="research_team")
    elif any(keyword in messages[-1].content for keyword in ["ì‘ì„±", "ê¸€ì“°ê¸°", "ì½˜í…ì¸ "]):
        return Command(goto="content_team")
    else:
        return Command(goto=END)

# ìµœìƒìœ„ ê·¸ë˜í”„ êµ¬ì„±
top_builder = StateGraph(MessagesState)
top_builder.add_node("top_level_supervisor", top_level_supervisor)
top_builder.add_node("research_team", research_team)
top_builder.add_node("content_team", content_team)

top_builder.add_edge(START, "top_level_supervisor")
top_builder.add_edge("research_team", "top_level_supervisor")
top_builder.add_edge("content_team", "top_level_supervisor")

hierarchical_system = top_builder.compile()
```

### ì¥ì ê³¼ ë‹¨ì 

**ì¥ì :**
- âœ… **í™•ì¥ì„±**: ëŒ€ê·œëª¨ ì‹œìŠ¤í…œì— ìµœì 
- âœ… **ì¡°ì§ì„±**: ëª…í™•í•œ ì±…ì„ ë¶„ë‹´
- âœ… **ì „ë¬¸ì„±**: ì„¸ë¶„í™”ëœ ì „ë¬¸ ì˜ì—­

**ë‹¨ì :**
- âŒ **ë³µì¡ì„±**: êµ¬í˜„ê³¼ ê´€ë¦¬ê°€ ë³µì¡
- âŒ **ì˜¤ë²„í—¤ë“œ**: ë‹¤ì¸µ êµ¬ì¡°ë¡œ ì¸í•œ ì§€ì—°
- âŒ **í†µì‹  ë¹„ìš©**: ê³„ì¸µ ê°„ í†µì‹  ë¹„ìš© ì¦ê°€

---

## ğŸ”„ 5. Custom Multi-Agent Workflow

### íŠ¹ì§•
- **ëª…ì‹œì  ì œì–´ íë¦„**: ë¯¸ë¦¬ ì •ì˜ëœ ì›Œí¬í”Œë¡œìš°
- **ì¡°ê±´ë¶€ ë¶„ê¸°**: ìƒí™©ì— ë”°ë¥¸ ë™ì  ê²½ë¡œ ì„ íƒ
- **í•˜ì´ë¸Œë¦¬ë“œ ì ‘ê·¼**: ì •ì  + ë™ì  ìš”ì†Œ ê²°í•©

---

## ğŸ¤ Handoffsì™€ Communication

### Handoff ê¸°ë³¸ ê°œë…

**HandoffëŠ” í•œ ì—ì´ì „íŠ¸ê°€ ë‹¤ë¥¸ ì—ì´ì „íŠ¸ì—ê²Œ ì œì–´ê¶Œì„ ë„˜ê¸°ëŠ” ë©”ì»¤ë‹ˆì¦˜ì´ë‹¤.**

#### ê¸°ë³¸ Handoff êµ¬ì¡°
```python
from langgraph.types import Command

def agent_with_handoff(state):
    # ì‘ì—… ìˆ˜í–‰
    result = perform_task(state)
    
    # ë‹¤ìŒ ì—ì´ì „íŠ¸ ê²°ì •
    next_agent = decide_next_agent(result)
    
    return Command(
        goto=next_agent,           # ëª©ì ì§€
        update={"key": "value"},   # ìƒíƒœ ì—…ë°ì´íŠ¸
        graph=Command.PARENT       # ê·¸ë˜í”„ ì§€ì • (ì˜µì…˜)
    )
```

#### Toolë¡œì„œì˜ Handoff
```python
from langchain_core.tools import tool

@tool
def transfer_to_specialist(specialist_type: str, context: str = "") -> Command:
    """ì „ë¬¸ê°€ì—ê²Œ ì‘ì—… ì´ì–‘
    
    Args:
        specialist_type: ì „ë¬¸ê°€ ìœ í˜•
        context: ì „ë‹¬í•  ì»¨í…ìŠ¤íŠ¸
    """
    return Command(
        goto=f"{specialist_type}_agent",
        update={
            "transfer_context": context,
            "transfer_time": time.time()
        },
        graph=Command.PARENT
    )
```

### ë©”ì‹œì§€ í‘œí˜„ ì „ëµ

#### 1. ì—ì´ì „íŠ¸ ì´ë¦„ í¬í•¨
```python
def named_agent_response(state, agent_name: str):
    """ì—ì´ì „íŠ¸ ì´ë¦„ì´ í¬í•¨ëœ ì‘ë‹µ"""
    response = model.invoke(state["messages"])
    
    # OpenAIì˜ name íŒŒë¼ë¯¸í„° í™œìš©
    return {
        "messages": [AIMessage(
            content=response.content,
            name=agent_name  # ì—ì´ì „íŠ¸ ì´ë¦„ ëª…ì‹œ
        )]
    }
```

#### 2. ì½˜í…ì¸ ì— ì—ì´ì „íŠ¸ ì •ë³´ í¬í•¨
```python
def tagged_agent_response(state, agent_name: str):
    """íƒœê·¸ê°€ í¬í•¨ëœ ì‘ë‹µ"""
    response = model.invoke(state["messages"])
    
    tagged_content = f"<agent>{agent_name}</agent><message>{response.content}</message>"
    
    return {"messages": [AIMessage(content=tagged_content)]}
```

#### 3. Handoff ë©”ì‹œì§€ ì²˜ë¦¬
```python
def handle_handoff_message(handoff_message: str) -> str:
    """Handoff ë„êµ¬ ë©”ì‹œì§€ ì²˜ë¦¬"""
    # ì˜µì…˜ 1: í™•ì¸ ë©”ì‹œì§€ ì¶”ê°€
    tool_message = ToolMessage(
        content=f"Successfully transferred to {handoff_message}",
        tool_call_id="transfer_123"
    )
    
    # ì˜µì…˜ 2: AI ë©”ì‹œì§€ ì œê±° (tool call í¬í•¨)
    # filtered_messages = [msg for msg in messages if not (
    #     isinstance(msg, AIMessage) and msg.tool_calls
    # )]
    
    return tool_message
```

---

## ğŸ—‚ï¸ State ê´€ë¦¬ ì „ëµ

### 1. ê³µìœ  ë©”ì‹œì§€ ë¦¬ìŠ¤íŠ¸

#### ì „ì²´ ì‚¬ê³  ê³¼ì • ê³µìœ 
```python
class FullThoughtState(MessagesState):
    """ëª¨ë“  ì—ì´ì „íŠ¸ì˜ ì‚¬ê³  ê³¼ì •ì„ ê³µìœ """
    agent_thoughts: list[dict]  # ê° ì—ì´ì „íŠ¸ì˜ ìƒì„¸ ì‚¬ê³  ê³¼ì •

def thinking_agent(state: FullThoughtState):
    """ì‚¬ê³  ê³¼ì •ì„ ê¸°ë¡í•˜ëŠ” ì—ì´ì „íŠ¸"""
    # ë‚´ë¶€ ì¶”ë¡  ê³¼ì •
    internal_thoughts = [
        "ì‚¬ìš©ì ì§ˆë¬¸ ë¶„ì„: ...",
        "ê´€ë ¨ ì •ë³´ ê²€ìƒ‰: ...", 
        "ë‹µë³€ êµ¬ì„±: ..."
    ]
    
    final_response = model.invoke(state["messages"])
    
    return {
        "messages": [final_response],
        "agent_thoughts": state.get("agent_thoughts", []) + [{
            "agent": "thinking_agent",
            "thoughts": internal_thoughts,
            "final_output": final_response.content
        }]
    }
```

#### ìµœì¢… ê²°ê³¼ë§Œ ê³µìœ 
```python
class ResultOnlyState(MessagesState):
    """ìµœì¢… ê²°ê³¼ë§Œ ê³µìœ í•˜ëŠ” ìƒíƒœ"""
    private_workspaces: dict  # ì—ì´ì „íŠ¸ë³„ ê°œì¸ ì‘ì—…ê³µê°„

def private_agent(state: ResultOnlyState):
    """ê°œì¸ ì‘ì—…ê³µê°„ì„ ê°€ì§„ ì—ì´ì „íŠ¸"""
    agent_name = "private_agent"
    
    # ê°œì¸ ì‘ì—…ê³µê°„ì—ì„œ ì‘ì—…
    workspace = state.get("private_workspaces", {}).get(agent_name, {})
    
    # ë‚´ë¶€ ì‘ì—… (ì™¸ë¶€ì— ë…¸ì¶œë˜ì§€ ì•ŠìŒ)
    internal_analysis = perform_internal_analysis(state["messages"])
    workspace["analysis_history"] = workspace.get("analysis_history", []) + [internal_analysis]
    
    # ìµœì¢… ê²°ê³¼ë§Œ ê³µìœ 
    final_result = generate_final_answer(internal_analysis)
    
    return {
        "messages": [AIMessage(content=final_result)],
        "private_workspaces": {
            **state.get("private_workspaces", {}),
            agent_name: workspace
        }
    }
```

### 2. ì—ì´ì „íŠ¸ë³„ ìƒíƒœ ìŠ¤í‚¤ë§ˆ

#### ì„œë¸Œê·¸ë˜í”„ í™œìš©
```python
from typing import TypedDict

class AnalysisState(TypedDict):
    """ë¶„ì„ ì „ìš© ìƒíƒœ"""
    raw_data: list
    analysis_result: dict
    confidence_score: float

class WritingState(TypedDict):
    """ì‘ì„± ì „ìš© ìƒíƒœ"""
    outline: str
    draft: str
    style_guide: dict

def create_specialized_subgraph():
    """ì „ë¬¸í™”ëœ ì„œë¸Œê·¸ë˜í”„"""
    
    def analysis_node(state: AnalysisState):
        # ë¶„ì„ ì „ìš© ë¡œì§
        result = analyze_data(state["raw_data"])
        return {
            "analysis_result": result,
            "confidence_score": calculate_confidence(result)
        }
    
    def writing_node(state: WritingState):
        # ì‘ì„± ì „ìš© ë¡œì§
        draft = write_content(state["outline"], state["style_guide"])
        return {"draft": draft}
    
    # ê°ê° ë³„ë„ì˜ ìƒíƒœ ìŠ¤í‚¤ë§ˆ ì‚¬ìš©
    analysis_graph = StateGraph(AnalysisState)
    writing_graph = StateGraph(WritingState)
    
    return analysis_graph, writing_graph
```

### 3. ë©”ì‹œì§€ í•„í„°ë§

```python
def filter_messages_for_agent(messages: list, agent_name: str) -> list:
    """íŠ¹ì • ì—ì´ì „íŠ¸ë¥¼ ìœ„í•œ ë©”ì‹œì§€ í•„í„°ë§"""
    filtered = []
    
    for message in messages:
        # ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” í•­ìƒ í¬í•¨
        if isinstance(message, SystemMessage):
            filtered.append(message)
        
        # ìì‹ ì˜ ë©”ì‹œì§€ì™€ ì‚¬ìš©ì ë©”ì‹œì§€ë§Œ í¬í•¨
        elif isinstance(message, (HumanMessage, AIMessage)):
            if hasattr(message, 'name') and message.name == agent_name:
                filtered.append(message)
            elif isinstance(message, HumanMessage):
                filtered.append(message)
        
        # ë‹¤ë¥¸ ì—ì´ì „íŠ¸ì˜ ë„êµ¬ í˜¸ì¶œì€ ì œì™¸
        elif isinstance(message, AIMessage) and message.tool_calls:
            relevant_calls = [
                call for call in message.tool_calls 
                if call.get("function", {}).get("name", "").startswith(agent_name)
            ]
            if relevant_calls:
                filtered.append(AIMessage(
                    content=message.content,
                    tool_calls=relevant_calls
                ))
    
    return filtered
```

---

## ğŸ¯ ì‹¤ì „ ì„¤ê³„ ê°€ì´ë“œ

### 1. ì•„í‚¤í…ì²˜ ì„ íƒ ê²°ì • íŠ¸ë¦¬

```python
def choose_architecture(requirements: dict) -> str:
    """ìš”êµ¬ì‚¬í•­ì— ë”°ë¥¸ ì•„í‚¤í…ì²˜ ì„ íƒ"""
    
    # ì—ì´ì „íŠ¸ ìˆ˜
    agent_count = requirements.get("agent_count", 0)
    
    # ë³µì¡ë„
    complexity = requirements.get("complexity", "low")  # low, medium, high
    
    # ì œì–´ í•„ìš”ì„±
    control_needed = requirements.get("control_needed", False)
    
    # í™•ì¥ì„± ìš”êµ¬
    scalability = requirements.get("scalability", "low")  # low, medium, high
    
    if agent_count <= 3 and complexity == "low":
        return "Custom Workflow"
    
    elif agent_count <= 5 and control_needed:
        return "Supervisor"
    
    elif agent_count <= 5 and not control_needed:
        return "Supervisor (Tool-calling)"
    
    elif agent_count > 5 and scalability == "high":
        return "Hierarchical"
    
    elif complexity == "high" and not control_needed:
        return "Network"
    
    else:
        return "Supervisor"
```

### 2. ë‹¨ê³„ë³„ êµ¬í˜„ ì „ëµ

#### Phase 1: í”„ë¡œí† íƒ€ì…
```python
# 1ë‹¨ê³„: ê°€ì¥ ê°„ë‹¨í•œ í˜•íƒœë¡œ ì‹œì‘
def simple_prototype():
    """ê°„ë‹¨í•œ í”„ë¡œí† íƒ€ì…"""
    
    @tool
    def research_tool(query: str) -> str:
        return f"Research result for: {query}"
    
    @tool  
    def write_tool(content: str) -> str:
        return f"Written content based on: {content}"
    
    tools = [research_tool, write_tool]
    supervisor = create_react_agent(model, tools)
    
    return supervisor
```

#### Phase 2: ì „ë¬¸í™”
```python
# 2ë‹¨ê³„: ì—ì´ì „íŠ¸ ì „ë¬¸í™”
def specialized_agents():
    """ì „ë¬¸í™”ëœ ì—ì´ì „íŠ¸ë“¤"""
    
    def research_agent(state):
        # ì—°êµ¬ ì „ë¬¸ ë¡œì§
        pass
    
    def writing_agent(state):
        # ì‘ì„± ì „ë¬¸ ë¡œì§
        pass
    
    # Supervisor íŒ¨í„´ ì ìš©
    return build_supervisor_system([research_agent, writing_agent])
```

#### Phase 3: í™•ì¥
```python
# 3ë‹¨ê³„: ì‹œìŠ¤í…œ í™•ì¥
def scaled_system():
    """í™•ì¥ëœ ì‹œìŠ¤í…œ"""
    
    # íŒ€ë³„ ì„œë¸Œì‹œìŠ¤í…œ
    research_team = build_research_team()
    content_team = build_content_team()
    review_team = build_review_team()
    
    # ê³„ì¸µì  êµ¬ì¡°
    return build_hierarchical_system([research_team, content_team, review_team])
```

### 3. ì„±ëŠ¥ ìµœì í™”

#### ë³‘ë ¬ ì²˜ë¦¬ ìµœì í™”
```python
from langgraph.constants import Send

def optimized_parallel_processing(state):
    """ìµœì í™”ëœ ë³‘ë ¬ ì²˜ë¦¬"""
    tasks = state["pending_tasks"]
    
    # ì‘ì—… íƒ€ì…ë³„ ê·¸ë£¹í™”
    task_groups = group_tasks_by_type(tasks)
    
    # ê° ê·¸ë£¹ë³„ë¡œ ìµœì ì˜ ì—ì´ì „íŠ¸ì—ê²Œ í• ë‹¹
    parallel_sends = []
    for task_type, task_list in task_groups.items():
        optimal_agent = select_optimal_agent(task_type, task_list)
        parallel_sends.append(
            Send(optimal_agent, {"tasks": task_list})
        )
    
    return parallel_sends

def select_optimal_agent(task_type: str, tasks: list) -> str:
    """ì‘ì—… ìœ í˜•ê³¼ ë¶€í•˜ì— ë”°ë¥¸ ìµœì  ì—ì´ì „íŠ¸ ì„ íƒ"""
    available_agents = get_available_agents(task_type)
    
    # ë¶€í•˜ ë¶„ì‚° ê³ ë ¤
    least_loaded = min(available_agents, key=lambda a: get_agent_load(a))
    
    return least_loaded
```

#### ë©”ëª¨ë¦¬ ê´€ë¦¬
```python
def memory_efficient_state(state: MessagesState) -> MessagesState:
    """ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ìƒíƒœ ê´€ë¦¬"""
    messages = state["messages"]
    
    # ì¤‘ìš”í•œ ë©”ì‹œì§€ë§Œ ìœ ì§€
    important_messages = []
    
    # ì‹œìŠ¤í…œ ë©”ì‹œì§€ëŠ” í•­ìƒ ìœ ì§€
    system_messages = [m for m in messages if isinstance(m, SystemMessage)]
    
    # ìµœê·¼ Nê°œ ë©”ì‹œì§€ ìœ ì§€
    recent_messages = messages[-10:]
    
    # ì¤‘ìš”í•œ ê²°ì •ì  ë©”ì‹œì§€ ìœ ì§€
    decision_messages = [
        m for m in messages 
        if "ê²°ì •" in m.content or "ì„ íƒ" in m.content
    ]
    
    # ì¤‘ë³µ ì œê±°í•˜ë©´ì„œ í•©ì¹˜ê¸°
    seen = set()
    for msg in system_messages + decision_messages + recent_messages:
        msg_id = id(msg)
        if msg_id not in seen:
            important_messages.append(msg)
            seen.add(msg_id)
    
    return {"messages": important_messages}
```

---

## ğŸ“‹ íŒ¨í„´ ì„ íƒ ê°€ì´ë“œ

### ìƒí™©ë³„ ê¶Œì¥ íŒ¨í„´

| ìƒí™© | ê¶Œì¥ íŒ¨í„´ | ì´ìœ  |
|------|-----------|------|
| **ì‹œì‘ ë‹¨ê³„ (3ê°œ ì´í•˜ ì—ì´ì „íŠ¸)** | Supervisor (Tool-calling) | êµ¬í˜„ ë‹¨ìˆœ, ë¹ ë¥¸ ê°œë°œ |
| **ì¤‘ê°„ ê·œëª¨ (3-7ê°œ ì—ì´ì „íŠ¸)** | Supervisor | ëª…í™•í•œ ì œì–´, í™•ì¥ ìš©ì´ |
| **ëŒ€ê·œëª¨ (7ê°œ ì´ìƒ ì—ì´ì „íŠ¸)** | Hierarchical | ì¡°ì§ì  ê´€ë¦¬, í™•ì¥ì„± |
| **ë™ë“±í•œ í˜‘ë ¥ì´ í•„ìš”í•œ ê²½ìš°** | Network | ìœ ì—°í•œ ìƒí˜¸ì‘ìš© |
| **ì •í•´ì§„ ìˆœì„œê°€ ìˆëŠ” ê²½ìš°** | Custom Workflow | ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì‹¤í–‰ |

### ë³µì¡ë„ë³„ ì„ íƒ

#### ë‚®ì€ ë³µì¡ë„
```python
# Tool-calling ë°©ì‹ìœ¼ë¡œ ì‹œì‘
tools = [agent_1_tool, agent_2_tool, agent_3_tool]
simple_system = create_react_agent(model, tools)
```

#### ì¤‘ê°„ ë³µì¡ë„
```python
# Supervisor íŒ¨í„´ ì ìš©
def build_supervisor_system():
    builder = StateGraph(MessagesState)
    builder.add_node("supervisor", supervisor_node)
    builder.add_node("agent_1", agent_1_node)
    builder.add_node("agent_2", agent_2_node)
    # ... ì—ì§€ êµ¬ì„±
    return builder.compile()
```

#### ë†’ì€ ë³µì¡ë„
```python
# Hierarchical ë˜ëŠ” Network íŒ¨í„´
def build_complex_system():
    # íŒ€ë³„ ì„œë¸Œì‹œìŠ¤í…œ êµ¬ì„±
    team_graphs = create_team_graphs()
    
    # ìµœìƒìœ„ ì¡°ì •ì
    top_level = create_top_level_supervisor(team_graphs)
    
    return top_level
```

---

## âœ… ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

### 1. ì„¤ê³„ ì›ì¹™

#### ë‹¨ì¼ ì±…ì„ ì›ì¹™
```python
# âœ… ì¢‹ì€ ì˜ˆ: ëª…í™•í•œ ë‹¨ì¼ ì±…ì„
def research_agent(state):
    """ì˜¤ì§ ì •ë³´ ìˆ˜ì§‘ë§Œ ë‹´ë‹¹"""
    query = extract_query(state)
    research_result = perform_research(query)
    return {"research_result": research_result}

# âŒ ë‚˜ìœ ì˜ˆ: ì—¬ëŸ¬ ì±…ì„ì´ ì„ì„
def multi_purpose_agent(state):
    """ì—°êµ¬, ì‘ì„±, ê²€í† ë¥¼ ëª¨ë‘ ìˆ˜í–‰"""
    research = perform_research(state)
    content = write_content(research)
    review = review_content(content)
    return {"final_result": review}
```

#### ëª…í™•í•œ ì¸í„°í˜ì´ìŠ¤
```python
# âœ… ëª…í™•í•œ ì—ì´ì „íŠ¸ ì¸í„°í˜ì´ìŠ¤
class AgentInterface:
    def process(self, input_data: dict) -> dict:
        """í‘œì¤€ ì²˜ë¦¬ ì¸í„°í˜ì´ìŠ¤"""
        pass
    
    def get_capabilities(self) -> list:
        """ì—ì´ì „íŠ¸ ì—­ëŸ‰ ì •ë³´"""
        pass
    
    def get_status(self) -> dict:
        """í˜„ì¬ ìƒíƒœ ì •ë³´"""
        pass
```

### 2. ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬

```python
def robust_agent(state):
    """ê²¬ê³ í•œ ì—ëŸ¬ ì²˜ë¦¬ê°€ í¬í•¨ëœ ì—ì´ì „íŠ¸"""
    try:
        result = perform_main_task(state)
        return {"result": result, "status": "success"}
    
    except SpecificError as e:
        # íŠ¹ì • ì—ëŸ¬ì— ëŒ€í•œ ë³µêµ¬ ì‹œë„
        fallback_result = perform_fallback_task(state)
        return {
            "result": fallback_result, 
            "status": "fallback",
            "error": str(e)
        }
    
    except Exception as e:
        # ì¼ë°˜ ì—ëŸ¬ ì²˜ë¦¬
        return {
            "status": "error",
            "error": str(e),
            "needs_human_intervention": True
        }

def error_recovery_supervisor(state):
    """ì—ëŸ¬ ë³µêµ¬ ìˆ˜í¼ë°”ì´ì €"""
    last_result = state.get("last_result", {})
    
    if last_result.get("status") == "error":
        if last_result.get("needs_human_intervention"):
            return Command(goto="human_review_agent")
        else:
            return Command(goto="retry_agent")
    
    return Command(goto="next_normal_agent")
```

### 3. ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…

```python
import logging
from datetime import datetime

def monitored_agent(state, agent_name: str):
    """ëª¨ë‹ˆí„°ë§ì´ í¬í•¨ëœ ì—ì´ì „íŠ¸"""
    start_time = datetime.now()
    
    logging.info(f"[{agent_name}] ì‹œì‘: {start_time}")
    logging.debug(f"[{agent_name}] ì…ë ¥ ìƒíƒœ: {state}")
    
    try:
        result = perform_agent_task(state)
        
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        logging.info(f"[{agent_name}] ì™„ë£Œ: {duration:.2f}ì´ˆ")
        logging.debug(f"[{agent_name}] ì¶œë ¥ ê²°ê³¼: {result}")
        
        # ì„±ëŠ¥ ë©”íŠ¸ë¦­ ê¸°ë¡
        record_performance_metric(agent_name, duration, "success")
        
        return result
    
    except Exception as e:
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        logging.error(f"[{agent_name}] ì—ëŸ¬ ({duration:.2f}ì´ˆ): {str(e)}")
        record_performance_metric(agent_name, duration, "error")
        
        raise

def record_performance_metric(agent_name: str, duration: float, status: str):
    """ì„±ëŠ¥ ë©”íŠ¸ë¦­ ê¸°ë¡"""
    # ì‹¤ì œë¡œëŠ” ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì— ì „ì†¡
    print(f"Metric: {agent_name} - {duration:.2f}s - {status}")
```

### 4. í…ŒìŠ¤íŠ¸ ì „ëµ

```python
import pytest
from unittest.mock import Mock

class TestMultiAgentSystem:
    
    def test_supervisor_routing(self):
        """ìˆ˜í¼ë°”ì´ì € ë¼ìš°íŒ… í…ŒìŠ¤íŠ¸"""
        # Given
        mock_state = {"messages": [HumanMessage("ì—°êµ¬ ìš”ì²­")]}
        
        # When
        result = supervisor(mock_state)
        
        # Then
        assert result.goto == "research_agent"
    
    def test_agent_handoff(self):
        """ì—ì´ì „íŠ¸ ê°„ handoff í…ŒìŠ¤íŠ¸"""
        # Given
        initial_state = {"messages": [HumanMessage("test")]}
        
        # When
        result = research_agent(initial_state)
        
        # Then
        assert "research_result" in result
        assert result["goto"] == "writing_agent"
    
    def test_error_handling(self):
        """ì—ëŸ¬ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        # Given
        error_state = {"messages": [], "force_error": True}
        
        # When & Then
        with pytest.raises(SpecificError):
            faulty_agent(error_state)
    
    @pytest.mark.integration
    def test_end_to_end_workflow(self):
        """ì „ì²´ ì›Œí¬í”Œë¡œìš° í†µí•© í…ŒìŠ¤íŠ¸"""
        # Given
        system = build_multi_agent_system()
        initial_input = {"messages": [HumanMessage("ë³µì¡í•œ ì‘ì—… ìš”ì²­")]}
        
        # When
        final_result = system.invoke(initial_input)
        
        # Then
        assert final_result["status"] == "completed"
        assert len(final_result["messages"]) > 0
```

---

## ğŸ‰ ê²°ë¡ 

Multi-Agent ì‹œìŠ¤í…œì€ ë³µì¡í•œ AI ì• í”Œë¦¬ì¼€ì´ì…˜ì„ êµ¬ì¶•í•˜ê¸° ìœ„í•œ ê°•ë ¥í•œ ì•„í‚¤í…ì²˜ íŒ¨í„´ì´ë‹¤.

### ğŸ¯ í•µì‹¬ ì›ì¹™

1. **ë‹¨ìˆœí•¨ì—ì„œ ì‹œì‘**: ê°€ì¥ ê°„ë‹¨í•œ íŒ¨í„´ë¶€í„° ì‹œì‘í•˜ì—¬ ì ì§„ì  í™•ì¥
2. **ëª…í™•í•œ ì±…ì„ ë¶„ë‹´**: ê° ì—ì´ì „íŠ¸ì˜ ì—­í• ê³¼ ì±…ì„ì„ ëª…í™•íˆ ì •ì˜
3. **íš¨ìœ¨ì ì¸ í†µì‹ **: ì—ì´ì „íŠ¸ ê°„ í†µì‹  ë°©ì‹ê³¼ ìƒíƒœ ê´€ë¦¬ ì „ëµ ìˆ˜ë¦½
4. **ê²¬ê³ í•œ ì—ëŸ¬ ì²˜ë¦¬**: ì‹¤íŒ¨ ìƒí™©ì— ëŒ€í•œ ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„

### ğŸš€ ì„ íƒ ê°€ì´ë“œ

| í”„ë¡œì íŠ¸ ë‹¨ê³„ | ê¶Œì¥ ì‹œì‘ì  | í™•ì¥ ë°©í–¥ |
|---------------|-------------|-----------|
| **í”„ë¡œí† íƒ€ì…** | Supervisor (Tool-calling) | â†’ Supervisor |
| **MVP** | Supervisor | â†’ Hierarchical |
| **í”„ë¡œë•ì…˜** | Hierarchical | â†’ Custom Hybrid |

### ğŸ’¡ ì‹¤ë¬´ íŒ

- **ì‹œì‘ì€ ë‹¨ìˆœí•˜ê²Œ**: Tool-calling ë°©ì‹ìœ¼ë¡œ ì‹œì‘
- **ì ì§„ì  í™•ì¥**: í•„ìš”ì— ë”°ë¼ ë³µì¡ë„ ì¦ê°€
- **ëª¨ë‹ˆí„°ë§ í•„ìˆ˜**: ì—ì´ì „íŠ¸ ì„±ëŠ¥ê³¼ ìƒí˜¸ì‘ìš© ì¶”ì 
- **í…ŒìŠ¤íŠ¸ ìë™í™”**: ê° íŒ¨í„´ë³„ í…ŒìŠ¤íŠ¸ ì „ëµ ìˆ˜ë¦½

> **Multi-Agent ì‹œìŠ¤í…œì˜ ì§„ì •í•œ ê°€ì¹˜ëŠ” ê° ì—ì´ì „íŠ¸ì˜ ì „ë¬¸ì„±ì„ ìµœëŒ€í•œ í™œìš©í•˜ë©´ì„œë„ ì „ì²´ ì‹œìŠ¤í…œì˜ ì¼ê´€ì„±ì„ ìœ ì§€í•˜ëŠ” ë° ìˆë‹¤.**

---

## ğŸ“š ì°¸ê³  ìë£Œ

- [LangGraph Multi-Agent Systems](https://langchain-ai.github.io/langgraph/concepts/multi_agent/)
- [Multi-Agent Collaboration Tutorial](https://langchain-ai.github.io/langgraph/tutorials/multi_agent/multi-agent-collaboration/)
- [Agent Supervisor Tutorial](https://langchain-ai.github.io/langgraph/tutorials/multi_agent/agent_supervisor/)
- [Hierarchical Agent Teams](https://langchain-ai.github.io/langgraph/tutorials/multi_agent/hierarchical_agent_teams/)
- [LangGraph Command Documentation](https://langchain-ai.github.io/langgraph/reference/types/#command)

---