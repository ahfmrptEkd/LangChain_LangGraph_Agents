# 🛡️ Pydantic 완전 가이드 for LangChain

> LangChain에서 구조화된 출력과 데이터 검증을 위한 Pydantic 활용법

## 📚 목차

- [Pydantic 기본 개념](#-pydantic-기본-개념)
- [BaseModel 기본 사용법](#-basemodel-기본-사용법)
- [Field를 통한 고급 검증](#-field를-통한-고급-검증)
- [Validator 심화 가이드](#-validator-심화-가이드)
- [LangChain과의 통합](#-langchain과의-통합)
- [실전 활용 패턴](#-실전-활용-패턴)
- [베스트 프랙티스](#-베스트-프랙티스)
- [트러블슈팅](#-트러블슈팅)

---

## 🎯 Pydantic 기본 개념

### 정의
**Pydantic**은 Python의 타입 힌트를 사용하여 데이터 검증과 직렬화를 수행하는 라이브러리입니다.

### 핵심 특징
- ✅ **타입 안전성**: Python 타입 힌트 기반 자동 검증
- ✅ **성능**: C로 작성된 코어로 빠른 처리
- ✅ **IDE 지원**: 자동완성과 타입 체크 지원
- ✅ **JSON 호환**: 자동 직렬화/역직렬화

### LangChain에서의 역할
```python
# LangChain + Pydantic 기본 흐름
LLM 출력 → Pydantic 모델 → 구조화된 데이터 → 애플리케이션 로직
```

---

## 🏗️ BaseModel 기본 사용법

### 기본 모델 정의
```python
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime

class Person(BaseModel):
    """개인 정보를 표현하는 기본 모델"""
    name: str
    age: int
    email: Optional[str] = None
    is_active: bool = True
    created_at: datetime = Field(default_factory=datetime.now)
```

### 모델 사용 예시
```python
# 1. 딕셔너리로부터 생성
person_data = {
    "name": "김철수",
    "age": 30,
    "email": "kim@example.com"
}
person = Person(**person_data)

# 2. 직접 생성
person = Person(name="김철수", age=30)

# 3. JSON에서 생성
json_str = '{"name": "김철수", "age": 30}'
person = Person.model_validate_json(json_str)

# 4. 딕셔너리로 변환
person_dict = person.model_dump()
# {'name': '김철수', 'age': 30, 'email': None, 'is_active': True, 'created_at': datetime(...)}

# 5. JSON으로 변환
person_json = person.model_dump_json()
# '{"name":"김철수","age":30,"email":null,"is_active":true,"created_at":"2024-01-01T10:00:00"}'
```

### 중첩 모델
```python
class Address(BaseModel):
    street: str
    city: str
    country: str = "한국"

class Company(BaseModel):
    name: str
    address: Address
    employees: List[Person]

# 사용 예시
company = Company(
    name="테크회사",
    address=Address(street="강남대로 123", city="서울"),
    employees=[
        Person(name="김철수", age=30),
        Person(name="이영희", age=25)
    ]
)
```

---

## 🔧 Field를 통한 고급 검증

### Field 기본 사용법
```python
from pydantic import BaseModel, Field
from typing import Annotated

class User(BaseModel):
    # 기본 제약조건
    name: str = Field(min_length=1, max_length=100, description="사용자 이름")
    age: int = Field(ge=0, le=150, description="나이 (0-150)")
    email: str = Field(pattern=r'^[\w\.-]+@[\w\.-]+\.\w+$', description="이메일 주소")
    
    # 숫자 제약조건
    score: float = Field(gt=0.0, lt=100.0, description="점수 (0-100 사이)")
    
    # 리스트 제약조건
    tags: List[str] = Field(max_length=10, description="최대 10개의 태그")
    
    # 기본값 설정
    status: str = Field(default="active", description="계정 상태")
    metadata: dict = Field(default_factory=dict, description="추가 메타데이터")
```

### Field 제약조건 옵션

| 타입 | 제약조건 | 설명 | 예시 |
|------|----------|------|------|
| **문자열** | `min_length`, `max_length` | 길이 제한 | `Field(min_length=1, max_length=50)` |
| | `pattern` | 정규식 패턴 | `Field(pattern=r'^\d{3}-\d{4}-\d{4}$')` |
| **숫자** | `gt`, `ge` | 초과, 이상 | `Field(gt=0)`, `Field(ge=1)` |
| | `lt`, `le` | 미만, 이하 | `Field(lt=100)`, `Field(le=99)` |
| **리스트** | `min_length`, `max_length` | 요소 개수 제한 | `Field(min_length=1, max_length=10)` |
| **모든 타입** | `description` | 필드 설명 | `Field(description="사용자 이름")` |
| | `default`, `default_factory` | 기본값 | `Field(default="N/A")` |

### Enum을 활용한 선택지 제한
```python
from enum import Enum

class UserRole(str, Enum):
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"

class User(BaseModel):
    name: str
    role: UserRole = UserRole.USER  # admin, user, guest 중 하나만 허용
    
    # 또는 Literal 사용
    from typing import Literal
    status: Literal["active", "inactive", "pending"] = "active"
```

---

## 🛡️ Validator 심화 가이드

### @field_validator (필드별 검증)
```python
from pydantic import BaseModel, field_validator
import re

class User(BaseModel):
    name: str
    email: str
    password: str
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v):
        """이름 검증: 한글, 영문만 허용"""
        if not re.match(r'^[가-힣a-zA-Z\s]+$', v):
            raise ValueError('이름은 한글 또는 영문만 가능합니다')
        return v.strip()
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v):
        """이메일 도메인 검증"""
        allowed_domains = ['gmail.com', 'naver.com', 'company.com']
        domain = v.split('@')[-1]
        if domain not in allowed_domains:
            raise ValueError(f'허용된 도메인이 아닙니다: {allowed_domains}')
        return v.lower()
    
    @field_validator('password')
    @classmethod
    def validate_password(cls, v):
        """비밀번호 강도 검증"""
        if len(v) < 8:
            raise ValueError('비밀번호는 8자 이상이어야 합니다')
        if not re.search(r'[A-Z]', v):
            raise ValueError('대문자를 포함해야 합니다')
        if not re.search(r'[0-9]', v):
            raise ValueError('숫자를 포함해야 합니다')
        return v
```

### @model_validator (모델 전체 검증)
```python
from pydantic import BaseModel, model_validator
from typing import Optional, List

class ExtractedData(BaseModel):
    people: List[dict] = Field(default_factory=list)
    companies: List[dict] = Field(default_factory=list)
    summary: Optional[str] = None
    
    @model_validator(mode='before')
    @classmethod
    def handle_none_values(cls, data):
        """LLM이 None을 반환하는 경우 처리"""
        if isinstance(data, dict):
            # None 값을 빈 리스트로 변환
            if data.get('people') is None:
                data['people'] = []
            if data.get('companies') is None:
                data['companies'] = []
        return data
    
    @model_validator(mode='after')
    @classmethod
    def validate_content(cls, model):
        """후처리 검증: 최소 하나의 데이터는 있어야 함"""
        if not model.people and not model.companies and not model.summary:
            raise ValueError('최소 하나의 정보는 추출되어야 합니다')
        return model
```

### Validator 모드 비교

| 모드 | 실행 시점 | 입력 타입 | 주요 용도 | 예시 |
|------|----------|----------|-----------|------|
| `mode='before'` | 필드 검증 전 | `dict` 또는 원본 | 데이터 전처리, 타입 변환 | None → [], 문자열 정리 |
| `mode='after'` | 필드 검증 후 | 모델 인스턴스 | 모델 간 관계 검증, 후처리 | 필드 간 일관성 체크 |

---

## 🔗 LangChain과의 통합

### with_structured_output 활용
```python
from langchain_openai import ChatOpenAI
from pydantic import BaseModel, Field

class MovieReview(BaseModel):
    """영화 리뷰 추출 모델"""
    title: str = Field(description="영화 제목")
    rating: int = Field(ge=1, le=5, description="평점 (1-5)")
    genre: str = Field(description="영화 장르")
    review_text: str = Field(description="리뷰 내용 요약")
    is_recommended: bool = Field(description="추천 여부")

# LLM과 연결
llm = ChatOpenAI(model="gpt-4o-mini")
structured_llm = llm.with_structured_output(
    schema=MovieReview,
    method="function_calling",
    include_raw=False
)

# 사용
review_text = "아바타는 정말 환상적인 영화였습니다. 시각 효과가 놀라웠고 5점 만점에 5점을 주고 싶어요!"
result = structured_llm.invoke(review_text)
print(type(result))  # <class 'MovieReview'>
print(result.title)  # "아바타"
print(result.rating)  # 5
```

### 복잡한 추출 시나리오
```python
from typing import List, Optional
from enum import Enum

class PersonRole(str, Enum):
    CEO = "ceo"
    CTO = "cto"
    DEVELOPER = "developer"
    DESIGNER = "designer"
    MANAGER = "manager"

class Person(BaseModel):
    name: str = Field(description="인물 이름")
    age: Optional[int] = Field(default=None, ge=0, le=120, description="나이")
    role: Optional[PersonRole] = Field(default=None, description="역할/직책")
    company: Optional[str] = Field(default=None, description="회사명")

class NewsArticle(BaseModel):
    title: str = Field(description="기사 제목")
    people: List[Person] = Field(default_factory=list, description="언급된 인물들")
    main_topic: str = Field(description="주요 주제")
    sentiment: Literal["positive", "negative", "neutral"] = Field(description="감정 분석")
    
    @model_validator(mode='after')
    @classmethod
    def validate_people_info(cls, model):
        """인물 정보 일관성 검증"""
        for person in model.people:
            if person.role == PersonRole.CEO and not person.company:
                raise ValueError(f"CEO {person.name}의 회사 정보가 누락되었습니다")
        return model
```

---

## 🎯 실전 활용 패턴

### 1. 단계별 추출 (Progressive Extraction)
```python
class BasicInfo(BaseModel):
    """1단계: 기본 정보 추출"""
    title: str
    main_topic: str

class DetailedInfo(BasicInfo):
    """2단계: 상세 정보 추가"""
    people: List[Person] = Field(default_factory=list)
    companies: List[str] = Field(default_factory=list)
    keywords: List[str] = Field(default_factory=list)

class FullAnalysis(DetailedInfo):
    """3단계: 완전한 분석"""
    sentiment: str
    summary: str
    confidence_score: float = Field(ge=0.0, le=1.0)
```

### 2. 조건부 필드 검증
```python
class UserProfile(BaseModel):
    name: str
    user_type: Literal["individual", "business"]
    
    # 개인 사용자 필드
    age: Optional[int] = None
    personal_id: Optional[str] = None
    
    # 비즈니스 사용자 필드
    company_name: Optional[str] = None
    business_number: Optional[str] = None
    
    @model_validator(mode='after')
    @classmethod
    def validate_user_type_fields(cls, model):
        """사용자 타입에 따른 필수 필드 검증"""
        if model.user_type == "individual":
            if not model.age or not model.personal_id:
                raise ValueError("개인 사용자는 나이와 개인ID가 필요합니다")
        elif model.user_type == "business":
            if not model.company_name or not model.business_number:
                raise ValueError("비즈니스 사용자는 회사명과 사업자번호가 필요합니다")
        return model
```

---

## 🎨 베스트 프랙티스

### 1. 필드 설명 작성 가이드
```python
class GoodExample(BaseModel):
    # ✅ 좋은 예: 구체적이고 명확한 설명
    name: str = Field(description="제품의 전체 이름 (브랜드명 포함)")
    price: float = Field(gt=0, description="제품 가격 (원화 기준, 정수 또는 소수)")
    category: str = Field(description="제품 카테고리 (전자제품, 의류, 식품 등)")
    
class BadExample(BaseModel):
    # ❌ 나쁜 예: 모호하고 불명확한 설명
    name: str = Field(description="이름")
    price: float = Field(description="가격")
    category: str = Field(description="카테고리")
```

### 2. 에러 처리 전략
```python
class RobustExtractionModel(BaseModel):
    name: Optional[str] = None
    age: Optional[int] = None
    email: Optional[str] = None
    
    @field_validator('age')
    @classmethod
    def validate_age(cls, v):
        """나이 검증 with 안전한 에러 처리"""
        if v is None:
            return None
        try:
            age = int(v)
            if 0 <= age <= 150:
                return age
            else:
                print(f"Warning: Invalid age {age}, setting to None")
                return None
        except (ValueError, TypeError):
            print(f"Warning: Cannot convert {v} to age, setting to None")
            return None
    
    @model_validator(mode='after')
    @classmethod
    def ensure_minimum_data(cls, model):
        """최소한의 데이터 보장"""
        if not any([model.name, model.age, model.email]):
            # 완전히 빈 결과보다는 기본값 제공
            model.name = "정보 없음"
        return model
```

### 3. 성능 최적화
```python
# Config 설정으로 성능 최적화
class OptimizedModel(BaseModel):
    model_config = {
        'validate_assignment': False,  # 할당 시 재검증 비활성화
        'use_enum_values': True,       # Enum 값 직접 사용
        'populate_by_name': True,      # 별칭으로 필드 접근 허용
    }
    
    name: str
    status: UserRole
```

---

## 🚨 트러블슈팅

### 자주 발생하는 오류와 해결책

#### 1. ValidationError: Input should be a valid list
```python
# ❌ 문제 상황
class DataModel(BaseModel):
    items: List[str]

# LLM이 None 반환 시 오류 발생
data = {"items": None}
model = DataModel(**data)  # ValidationError!

# ✅ 해결책
class DataModel(BaseModel):
    items: List[str] = Field(default_factory=list)
    
    @model_validator(mode='before')
    @classmethod
    def handle_none(cls, data):
        if isinstance(data, dict) and data.get('items') is None:
            data['items'] = []
        return data
```

#### 2. 한국어 이름 처리 오류
```python
# ✅ 한국어 친화적 검증
class KoreanNameModel(BaseModel):
    name: str
    
    @field_validator('name')
    @classmethod
    def validate_korean_name(cls, v):
        # 한글, 영문, 공백 허용
        import re
        if not re.match(r'^[가-힣a-zA-Z\s]+$', v):
            raise ValueError('한글 또는 영문 이름만 가능합니다')
        return v.strip()
```

#### 3. Optional vs Required 필드 혼동
```python
# ✅ 명확한 필드 정의
class ClearModel(BaseModel):
    # 필수 필드 (None 허용 안함)
    required_field: str
    
    # 선택 필드 (None 허용)
    optional_field: Optional[str] = None
    
    # 기본값 있는 필드
    default_field: str = "기본값"
    
    # 리스트 기본값 (빈 리스트)
    list_field: List[str] = Field(default_factory=list)
```

### 디버깅 팁
```python
# 1. 모델 스키마 확인
print(MyModel.model_json_schema())

# 2. 검증 오류 자세히 보기
try:
    model = MyModel(**data)
except ValidationError as e:
    print(e.errors())  # 상세 오류 정보
    for error in e.errors():
        print(f"Field: {error['loc']}, Error: {error['msg']}")

# 3. 모델 상태 확인
model = MyModel(**valid_data)
print(model.model_dump())  # 딕셔너리로 변환
print(model.model_dump_json(indent=2))  # 예쁜 JSON 출력
```

---

## 📚 참고 자료

- [Pydantic 공식 문서](https://docs.pydantic.dev/)
- [LangChain Structured Output 가이드](https://python.langchain.com/docs/how_to/structured_output/)
- [Python 타입 힌트 가이드](https://docs.python.org/3/library/typing.html)

---

*이 가이드는 Pydantic v2와 LangChain v0.3+ 기준으로 작성되었습니다.* 