# Query Translation for RAG

## 1. 개요 (Overview)
Query Translation은 사용자의 원본 질문을 RAG 시스템이 더 잘 이해할 수 있는 형태로 변환하여 검색 성능을 극대화하는 기법입니다. 사용자의 단일 질문만으로는 놓칠 수 있는 관련 문서를 다각도로 탐색함으로써, 최종 답변의 풍부함과 정확도를 향상시키는 것을 목표로 합니다.

## 2. 파일 구조 (File Structure)
```
query_translation/
├── README.md                           # 현재 파일
├── multi_query.py                      # Multi-Query RAG 구현
├── rag_fusion.py                       # RAG-Fusion 구현
├── decomposition.py                    # Query Decomposition 구현
├── step_back.py                        # Step-back Prompting 구현
├── HyDE.py                             # HyDE 구현
└── LangChain_Core_Components.md        # 핵심 컴포넌트 가이드
```

## 3. Query Translation 기법이 필요한 이유
표준 RAG는 사용자의 질문을 그대로 검색에 사용하기 때문에 몇 가지 본질적인 한계를 가집니다. Query Translation은 이러한 한계를 해결하기 위해 필요합니다.

- **RAG의 한계점 해결**:
    - **어휘 불일치 (Vocabulary Mismatch)**: 사용자가 사용하는 단어(예: "AI 비서")와 문서에 있는 전문 용어(예: "LLM Agent")가 다를 때 검색 성능이 저하되는 문제를 해결합니다.
    - **질문의 모호성 (Ambiguity of Query)**: 사용자의 질문이 너무 광범위하거나 여러 주제를 포함할 때, 핵심 의도를 명확히 하여 검색 정확도를 높입니다.
    - **컨텍스트 부족 (Lack of Context)**: 단일 질문에 명시적으로 드러나지 않은 배경지식이나 상위 개념을 함께 검색하여 답변의 깊이를 더합니다.

- **Query Translation의 역할**:
  이 기법은 원본 질문을 더 효과적인 여러 검색어로 변환하여 위 한계들을 극복합니다. 질문을 여러 개로 만들거나(Multi-Query), 더 일반적인 질문으로 바꾸거나(Step-back), 심지어 가상의 답변을 생성(HyDE)하여 **검색의 정확도(Precision)와 재현율(Recall)을 모두 높입니다.**

## 4. 각 기법들의 핵심 아이디어 및 장단점

### 1) Multi-Query RAG
- **핵심 아이디어**: 하나의 질문을 LLM을 사용해 여러 개의 다른 관점을 가진 질문으로 변환하여 동시에 검색합니다.
- **장점**: 다양한 관점에서 정보를 수집하여 재현율(Recall)을 높이고, 놓칠 수 있는 문서를 포착합니다.
- **단점**: 생성된 질문들의 품질이 LLM에 의존적이며, 관련 없는 질문이 생성될 경우 노이즈가 발생할 수 있습니다.

### 2) RAG-Fusion
- **핵심 아이디어**: Multi-Query와 유사하게 여러 질문을 생성하지만, 검색된 결과들을 Reciprocal Rank Fusion (RRF) 알고리즘으로 재정렬하여 가장 관련성 높은 문서를 상위로 올립니다.
- **장점**: 여러 검색 결과에서 공통적으로 상위에 랭크된 문서에 가중치를 부여하여 검색 정확도(Precision)를 크게 향상시킵니다.
- **단점**: RRF 계산을 위한 추가적인 단계가 필요합니다.

### 3) Query Decomposition
- **핵심 아이디어**: 여러 단계의 추론이 필요한 복잡한 질문을 여러 개의 간단한 하위 질문으로 분해합니다.
- **장점**: 복잡하고 다면적인 질문을 체계적으로 처리할 수 있으며, 각 단계별로 명확한 답변을 얻을 수 있습니다.
- **단점**: 질문을 분해하는 과정 자체가 복잡하며, 분해된 질문들이 원래 질문의 의도를 모두 포함하지 못할 위험이 있습니다.

### 4) Step-back Prompting
- **핵심 아이디어**: 구체적인 질문에서 한 걸음 물러나, 더 넓은 맥락을 포괄하는 일반적인 질문을 생성합니다. 이 두 가지 질문(원본+일반)을 모두 사용하여 문서를 검색합니다.
- **장점**: 원본 질문만으로는 찾기 어려운 상위 개념이나 배경지식을 함께 검색하여 더 풍부하고 깊이 있는 답변을 제공합니다.
- **단점**: 일반적인 질문이 너무 광범위할 경우, 관련 없는 정보가 검색될 수 있습니다.

### 5) HyDE (Hypothetical Document Embeddings)
- **핵심 아이디어**: 사용자의 질문에 대해 가상의 답변 문서(Hypothetical Document)를 먼저 생성하고, 이 가상 문서를 임베딩하여 실제 문서와 비교 검색합니다.
- **장점**: 사용자의 질문과 실제 문서 간의 어휘 불일치(semantic gap)를 효과적으로 해결합니다. 특히 전문 용어가 많은 도메인에서 강력합니다.
- **단점**: 생성된 가상 문서의 품질이 최종 검색 결과에 큰 영향을 미칩니다.

## 5. 기법별 비교 테이블
| 기법 | 질문 변환 방식 | 주요 장점 | 해결하는 RAG 한계점 |
|---|---|---|---|
| **Multi-Query** | 1→N 다양한 관점 | 포괄적 정보 수집 (Recall 향상) | 질문의 모호성 |
| **RAG-Fusion** | 1→N + RRF 순위화 | 높은 검색 정확도 (Precision 향상) | 검색 결과의 관련성 부족 |
| **Decomposition** | 1→N 하위 질문 | 복잡한 질문의 논리적 추론 | 다단계 질문 처리의 어려움 |
| **Step-back** | 1→2 (구체적→일반적) | 풍부한 배경지식 및 컨텍스트 제공 | 컨텍스트 부족 |
| **HyDE** | 1→가상문서→검색 | 어휘 불일치(Semantic Gap) 해결 | 사용자와 문서 간의 용어 차이 |

## 6. 활용 사례 (Use Cases)
빠른 적용을 위해 다음 가이드를 활용하세요.

- **일반적이고 포괄적인 정보가 필요할 때**: `Multi-Query`
  - 예: "머신러닝이란 무엇인가?"
- **매우 정확하고 신뢰도 높은 답변이 필요할 때**: `RAG-Fusion`
  - 예: "신경망에서 경사 하강법은 어떻게 작동하는가?"
- **여러 질문이 섞인 복잡한 문제를 해결할 때**: `Decomposition`
  - 예: "RAG 시스템을 처음부터 구축하고 평가하는 방법은?"
- **질문의 배경지식이나 더 넓은 맥락이 필요할 때**: `Step-back`
  - 예: "트랜스포머 아키텍처의 최신 발전 동향은?"
- **전문 용어가 많거나 특정 도메인의 문서를 검색할 때**: `HyDE`
  - 예: "NLP에서 어텐션 메커니즘의 중요성을 설명해줘."

## 7. 결론 및 핵심 인사이트
Query Translation은 단순한 검색을 넘어, **사용자의 의도와 데이터베이스의 정보 사이의 간극을 메우는** 핵심적인 RAG 최적화 전략입니다.

- **핵심 인사이트**:
    1.  **No Silver Bullet**: 완벽한 단일 기법은 없습니다. 질문의 유형(일반, 전문, 복합 등)과 목표(정확성, 포괄성 등)에 따라 적절한 기법을 선택하거나 조합해야 합니다.
    2.  **Recall과 Precision의 트레이드오프**: `Multi-Query`는 재현율(Recall)을 높이는 데 중점을 두는 반면, `RAG-Fusion`은 정확도(Precision)를 높이는 데 더 효과적입니다.
    3.  **프롬프트 엔지니어링의 중요성**: 대부분의 Query Translation 기법은 LLM을 사용하여 질문을 변환하므로, 원하는 결과(다양한 관점, 일반화, 분해 등)를 얻기 위한 프롬프트 엔지니어링이 성능을 좌우합니다.
    4.  **검색 품질의 상향 평준화**: 어떤 기법을 사용하든, 단일 원본 질문을 사용하는 것보다 거의 항상 더 나은 검색 결과를 제공합니다. RAG 시스템의 성능을 한 단계 끌어올리고 싶다면 Query Translation 도입은 필수적입니다.