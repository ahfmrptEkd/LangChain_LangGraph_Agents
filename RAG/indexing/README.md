# 🚀 RAG Indexing

## 파일 구조 (File Structure)
```
indexing/
├── multi_representation.py   # Multi-Representation 인덱싱 구현
├── raptor.py                 # RAPTOR 인덱싱 구현
└── README.md                 # 현재 문서
```

---

## 📖 목차
1. [개요 (Overview)](#1-개요-overview)
2. [Indexing이 필요한 이유](#2-indexing이-필요한-이유)
3. [구현된 기법들](#3-구현된-기법들)
    - [Multi-Representation](#-multi-representation)
    - [RAPTOR (Recursive Abstractive Processing)](#-raptor-recursive-abstractive-processing)
4. [기법별 비교 테이블](#4-기법별-비교-테이블)
5. [선택 가이드 (Use Cases)](#5-선택-가이드-use-cases)
6. [결론 및 핵심 인사이트](#6-결론-및-핵심-인사이트)

---

## 1. 개요 (Overview)

Indexing은 원본 문서들을 RAG 시스템이 효과적으로 검색할 수 있도록 **구조화하고 표현하는 과정**입니다. 단순히 문서를 그대로 사용하는 것을 넘어, 검색 성능을 극대화하기 위해 다양한 방식으로 문서를 가공하고 저장하는 것을 목표로 합니다.

---

## 2. Indexing이 필요한 이유

표준 RAG의 인덱싱은 문서를 고정된 크기로 분할(Chunking)하여 벡터로 만드는 방식에 의존하며, 이는 다음과 같은 한계를 가집니다.

-   **⚠️ 정보 손실 (Information Loss)**: 고정된 크기의 청크는 문맥을 완전히 담지 못하거나, 중요한 정보를 여러 청크에 분산시킬 수 있습니다.
-   **⚠️ 의미적 검색의 한계 (Semantic Search Limitation)**: 긴 문서의 핵심 내용을 하나의 벡터로 표현하기 어려워, 쿼리와의 의미적 유사도 계산이 부정확해질 수 있습니다.
-   **⚠️ 단일 관점의 한계 (Single-Perspective Limitation)**: 문서는 다양한 수준의 추상화(개요, 세부 내용 등)를 포함하지만, 표준 인덱싱은 이를 구분하지 못합니다.

**고급 인덱싱 기법들은 이러한 한계를 극복하기 위해 문서를 요약, 클러스터링, 계층화하는 등 다각도로 표현하여 검색의 정확성과 효율성을 높입니다.**

---

## 3. 구현된 기법들

### 🎯 Multi-Representation
-   **핵심 아이디어**: 문서의 **요약본을 벡터화하여 검색**하되, 사용자에게는 **원본 문서를 반환**하는 방식입니다. 검색 효율성과 정보의 완전성을 동시에 달성합니다.
-   **작동 방식**:
    ```python
    # 1. 원본 문서에 대한 요약본 생성
    summaries = create_summaries(docs)

    # 2. 이중 저장소(VectorStore, ByteStore) 설정
    # VectorStore: 요약본 저장 (검색용)
    # ByteStore: 원본 문서 저장 (반환용)
    retriever = MultiVectorRetriever(vectorstore=..., byte_store=...)

    # 3. 쿼리로 요약본을 검색한 뒤, 연결된 원본 문서를 반환
    retrieved_docs = retriever.invoke(query)
    ```
-   **장점**: 요약본을 통해 문서의 핵심 의미를 정확하게 검색하면서도, 정보 손실 없이 원본 내용을 제공할 수 있습니다.
-   **단점**: 모든 문서에 대한 요약 생성 비용이 발생하며, 요약의 품질이 검색 성능에 직접적인 영향을 미칩니다.

### 🎯 RAPTOR (Recursive Abstractive Processing)
-   **핵심 아이디어**: 문서들을 **계층적으로 클러스터링**하고 각 클러스터에 대한 **요약을 생성**하여, 다층적인 트리 구조로 정보를 조직화합니다.
-   **작동 방식**:
    ```python
    # 1. 문서들을 임베딩하고, GMM 클러스터링 수행
    clusters = perform_clustering(embeddings, ...)

    # 2. 각 클러스터의 문서들을 요약하여 상위 레벨의 노드 생성
    level_1_summaries = summarize_clusters(clusters)

    # 3. 요약본들을 다시 클러스터링하고 요약하는 과정을 반복 (재귀)
    results = recursive_embed_cluster_summarize(texts, ...)

    # 4. 원본 문서와 모든 레벨의 요약본을 함께 검색
    rag_chain.invoke(question)
    ```
-   **장점**: 세부적인 내용부터 전체적인 개요까지, 다양한 추상화 수준에서 정보를 검색할 수 있어 복잡한 질문에 효과적입니다.
-   **단점**: 클러스터링과 재귀적 요약 과정이 복잡하고, 상당한 계산 비용과 메모리를 필요로 합니다.

---

## 4. 기법별 비교 테이블

| 기법 | 인덱싱 방식 | 주요 장점 | 해결하는 RAG 한계점 |
| :--- | :--- | :--- | :--- |
| **Multi-Representation** | 요약본(검색) + 원본(반환) | 검색 정확도와 정보 완전성 동시 확보 | 의미적 검색의 한계 |
| **RAPTOR** | 재귀적 클러스터링 및 요약 | 다층적, 계층적 정보 검색 가능 | 단일 관점의 한계, 정보 손실 |

---

## 5. 선택 가이드 (Use Cases)

| 상황/목표 | 추천 기법 | 예시 |
| :--- | :--- | :--- |
| **긴 문서의 핵심 내용을 정확히 검색** | `Multi-Representation` | "수십 페이지 기술 문서에서 '메모리 관리'에 대한 핵심 내용을 찾아줘." |
| **대규모 문서 집합을 구조화하고 탐색** | `RAPTOR` | "수백 개의 법률 문서 전체에서 '계약 해지'와 관련된 조항들을 세부 및 요약 수준으로 모두 찾아줘." |
| **빠른 구현과 안정적인 성능 필요** | `Multi-Representation` | 일반적인 질의응답 시스템 구축 |
| **최고 수준의 컨텍스트 이해 필요** | `RAPTOR` | 연구 논문 데이터베이스나 기업 내부 지식 관리 시스템 구축 |

---

## 6. 결론 및 핵심 인사이트

> **"효과적인 인덱싱은 단순히 문서를 저장하는 것을 넘어, 정보에 대한 다각적인 접근 경로를 설계하는 과정입니다."**

-   **💡 표현의 다양성**: 문서를 원본 텍스트, 요약, 클러스터 등 다양한 형태로 표현할수록 검색 성능이 향상됩니다.
-   **💡 비용과 성능의 트레이드오프**: RAPTOR와 같이 복잡한 인덱싱은 높은 성능을 제공하지만, 상당한 계산 비용을 수반합니다. 사용 사례에 맞는 적절한 균형점을 찾아야 합니다.
-   **💡 검색 대상의 확장**: 고급 인덱싱은 검색 대상을 '문서 청크'에서 '의미 단위(요약, 클러스터)'로 확장하여, 더 정확하고 유연한 검색을 가능하게 합니다.