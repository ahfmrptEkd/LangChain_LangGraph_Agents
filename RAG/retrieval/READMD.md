# RAG Retrieval 기법 정리

## 개요
RAG(Retrieval-Augmented Generation)에서 retrieval 단계는 가장 중요한 구성 요소 중 하나입니다. 이 문서는 retrieval 시점에서 사용되는 다양한 고급 RAG 기법들의 특징과 동작 방식을 정리합니다.

---

## 1. RAG Fusion

### 특징
- **다중 쿼리 생성**: 하나의 질문에서 여러 개의 유사한 질문을 자동 생성
- **RRF(Reciprocal Rank Fusion)**: 각 쿼리별 검색 결과를 융합하여 최종 문서 순위 결정
- **검색 다양성 향상**: 다양한 관점에서 관련 문서 검색

### 동작 방식
1. 원본 질문 → LLM을 통해 3-5개의 변형 질문 생성
2. 각 질문별로 독립적인 벡터 검색 수행
3. RRF 알고리즘으로 검색 결과 융합
4. 최종 순위가 높은 문서들 선택

### 장점
- 단일 검색으로 놓칠 수 있는 관련 문서 발견
- 질문 표현의 한계 극복
- 검색 recall 개선

### 단점
- 검색 비용 증가 (다중 쿼리 실행)
- 생성된 질문의 품질에 의존
- 처리 시간 증가

### 적용 사례
```python
# 원본 질문: "What is machine learning?"
# 생성 질문들:
# - "How does machine learning work?"
# - "What are the applications of ML?"
# - "Explain artificial intelligence and ML"
```

---

## 2. Reranker (재순위화)

### 특징
- **검색 후 재정렬**: 초기 검색 결과를 질문과의 관련성 기준으로 재순위화
- **다양한 방법**: LLM Grading, Cross-Encoder, Cohere Rerank API 등
- **정밀도 향상**: 검색된 문서 중 실제로 관련성 높은 문서 우선 배치

### 동작 방식
1. 기본 벡터 검색으로 후보 문서 검색 (예: top-100)
2. 각 문서에 대해 질문과의 관련성 점수 계산
3. 점수 기준으로 문서 재정렬
4. 상위 문서들만 선택 (예: top-10)

### 재순위화 방법

#### 1) LLM Grading
- LLM이 문서의 관련성을 1-10점으로 평가
- 해석 가능한 점수 제공
- 비용이 높지만 정확도 우수

#### 2) Cross-Encoder
- BERT 기반 모델로 질문-문서 쌍의 관련성 점수 계산
- 빠른 추론 속도
- 사전 훈련된 모델 활용 가능

#### 3) Cohere Rerank API
- 전문 reranking 서비스
- 높은 성능과 안정성
- API 호출 비용 발생

### 장점
- 검색 정밀도 크게 향상
- 다양한 방법 선택 가능
- 기존 검색 시스템에 쉽게 추가 가능

### 단점
- 추가 계산 비용
- latency 증가
- 초기 검색 품질에 의존

---

## 3. CRAG (Corrective RAG)

### 특징
- **검색 품질 평가**: 검색된 문서의 품질을 자동으로 평가
- **적응적 전략**: 문서 품질에 따라 생성 또는 웹 검색 선택
- **자동 보정**: 부적절한 검색 결과를 웹 검색으로 보완

### 동작 방식
1. 질문에 대해 문서 검색
2. 문서 품질 평가 (relevant/irrelevant/ambiguous)
3. 품질에 따른 전략 선택:
   - **High Quality**: 바로 생성
   - **Low Quality**: 질문 변환 후 웹 검색
   - **Ambiguous**: 문서 필터링 후 생성

### 품질 평가 기준
- **Relevant**: 질문과 직접 관련된 정보 포함
- **Irrelevant**: 질문과 무관한 내용
- **Ambiguous**: 부분적으로 관련되지만 불충분

### 장점
- 검색 실패 시 자동 보정
- 다양한 정보 소스 활용
- 높은 답변 품질 보장

### 단점
- 복잡한 워크플로우
- 웹 검색 비용 추가
- 처리 시간 증가

---

## 4. Self-RAG (자체 반성 RAG)

### 특징
- **자체 평가**: 생성된 답변을 스스로 평가하고 개선
- **반복적 개선**: 품질이 낮으면 재검색 또는 재생성
- **신뢰도 점수**: 답변의 신뢰도를 함께 제공

### 동작 방식
1. 일반적인 RAG 프로세스 수행
2. 생성된 답변에 대해 자체 평가:
   - 사실성 검증
   - 질문 답변 적합성
   - 환각 여부 확인
3. 품질이 낮으면 재시도 또는 다른 전략 사용

### 평가 기준
- **Factual Accuracy**: 검색된 문서에 근거한 사실성
- **Question Relevance**: 질문에 대한 답변 적합성
- **Completeness**: 답변의 완전성
- **Consistency**: 내용의 일관성

### 장점
- 높은 답변 품질
- 신뢰도 점수 제공
- 자동 품질 관리

### 단점
- 높은 계산 비용
- 복잡한 구현
- 수렴하지 않을 위험

---

## 5. Adaptive RAG (적응형 RAG)

### 특징
- **질문 유형 분석**: 질문의 특성을 분석하여 최적 전략 선택
- **동적 라우팅**: 질문에 따라 벡터 검색 또는 웹 검색 선택
- **유연한 처리**: 다양한 질문 유형에 적응적 대응

### 동작 방식
1. 질문 분석 및 유형 분류
2. 질문 유형에 따른 검색 전략 선택:
   - **지식 기반 질문**: 벡터 검색
   - **최신 정보 질문**: 웹 검색
   - **복합 질문**: 하이브리드 접근
3. 선택된 전략으로 검색 및 생성

### 라우팅 전략
- **Vectorstore**: 기존 문서에서 답변 가능한 질문
- **Web Search**: 최신 정보나 실시간 데이터 필요
- **Hybrid**: 두 방법 모두 활용

### 장점
- 질문 유형별 최적화
- 효율적인 자원 활용
- 높은 답변 품질

### 단점
- 라우팅 정확도에 의존
- 시스템 복잡성 증가
- 초기 설정 비용

---

## 6. Agentic RAG (에이전트 기반 RAG)

### 특징
- **에이전트 기반**: 자율적인 의사결정을 통한 RAG 수행
- **도구 활용**: 다양한 검색 도구와 API 활용
- **계획 수립**: 복잡한 질문에 대해 단계별 접근

### 동작 방식
1. 질문 분석 및 해결 계획 수립
2. 필요한 도구 및 자원 식별
3. 단계별 정보 수집:
   - 벡터 검색
   - 웹 검색
   - API 호출
   - 계산 수행
4. 수집된 정보 통합 및 답변 생성

### 에이전트 도구
- **Search Tools**: 벡터 검색, 웹 검색, 특화 검색
- **API Tools**: 날씨, 주식, 뉴스 등 실시간 API
- **Calculation Tools**: 수학 계산, 데이터 분석
- **Memory Tools**: 대화 기록, 사용자 선호도

### 장점
- 복잡한 질문 해결 가능
- 다양한 정보 소스 활용
- 자율적인 문제 해결

### 단점
- 높은 구현 복잡성
- 예측 불가능한 비용
- 에이전트 신뢰성 이슈

---

## 🎯 세부 특징 및 장단점

| 방법론 | 핵심 특징 | 주요 장점 | 주요 단점 |
|--------|-----------|-----------|-----------|
| **RAG Fusion** | • 단일 쿼리 → 다중 쿼리 변환<br>• Reciprocal Rank Fusion<br>• 다양한 관점에서 검색 | • 더 포괄적인 답변<br>• 편향 감소<br>• 정확도 향상 | • 추가 LLM 호출 비용<br>• 쿼리 관련성 이탈 위험<br>• 처리 시간 증가 |
| **Reranker** | • Cross-encoder 기반<br>• 쿼리-문서 동시 인코딩<br>• 관련성 점수 기반 재정렬 | • 검색 정확도 대폭 개선<br>• 노이즈 감소<br>• 의미적 이해 향상 | • 계산 비용 높음<br>• 처리 속도 제한<br>• 문서 길이 제약 |
| **Self-RAG** | • 온디맨드 검색<br>• 자기 평가 메커니즘<br>• 4단계 검증 프로세스 | • 높은 팩트 정확도<br>• 인용 가능성<br>• 적응적 검색 | • 복잡한 훈련 과정<br>• 특수 토큰 필요<br>• 모델 크기 증가 |
| **CRAG** | • 문서 품질 평가<br>• 웹 검색 확장<br>• Decompose-then-recompose | • 검색 오류 교정<br>• 실시간 정보 보완<br>• 견고성 향상 | • 평가기 품질 의존<br>• 웹 검색 신뢰성<br>• 추가 복잡성 |
| **Adaptive RAG** | • 쿼리 복잡도 분석<br>• 전략적 라우팅<br>• 하이브리드 접근법 | • 효율성 최적화<br>• 다양한 쿼리 대응<br>• 자원 절약 | • 라우팅 정확도 의존<br>• 복잡한 설계<br>• 사전 분류 필요 |
| **Agentic RAG** | • 멀티 에이전트 시스템<br>• 동적 계획 및 실행<br>• 메모리 기반 학습 | • 복잡한 추론 가능<br>• 자율적 의사결정<br>• 확장성 높음 | • 높은 복잡성<br>• 디버깅 어려움<br>• 높은 계산 비용 |

<br>

## ⚙️ 이전 방법들과의 비교

| 구분 | 접근 방식 | 핵심 메커니즘 | 복잡성 |
|------|-----------|---------------|--------|
| **Reranker** | 2단계 검색 | Cross-encoder | 2단계 시스템 |
| **RAG Fusion** | 다중 쿼리 | Query generation + RRF | 다중 쿼리 처리 |
| **Self-RAG** | 자기성찰 | Reflection tokens | 단일 모델 |
| **CRAG** | 결과 교정 | Document evaluator | 단일 파이프라인 |
| **Adaptive RAG** | 전략 선택 | Query routing | 조건부 분기 |
| **Agentic RAG** | 에이전트 기반 | Multi-agent system | 복잡 워크플로우 |

<br> 

## 📊 기법별 비교 요약표

| 구분 | 핵심 포커스 | 주요 메커니즘 | 언제 사용? |
|------|-------------|---------------|------------|
| **Self-RAG** | 자기판단+평가 | Reflection/Critique tokens | 높은 신뢰성이 필요한 작업 |
| **CRAG** | 검색결과 교정 | Document evaluator + 웹검색 | 팩트 체킹이 중요한 분야 |
| **Adaptive RAG** | 쿼리별 라우팅 | Query analysis + 전략선택 | 다양한 유형의 쿼리 처리 |
| **Agentic RAG** | 에이전트 기반 | Multi-agent system | 복잡한 워크플로우 |
| **RAG Fusion** | 다중 쿼리 생성 | Multiple queries + RRF | 포괄적이고 정확한 답변 |
| **Reranker** | 결과 재순위화 | Cross-encoder scoring | 검색 정확도 개선 |


---

## 선택 가이드

### 1. 간단한 개선이 필요한 경우
- **Reranker**: 기존 시스템에 쉽게 추가 가능
- **RAG Fusion**: 검색 품질 향상 원함

### 2. 높은 품질이 중요한 경우
- **CRAG**: 정확성이 최우선
- **Self-RAG**: 신뢰도 점수 필요

### 3. 다양한 질문 유형 처리
- **Adaptive RAG**: 질문 유형별 최적화
- **Agentic RAG**: 복잡한 멀티스텝 질문

### 4. 비용 효율성 중요
- **Reranker**: 가장 경제적
- **RAG Fusion**: 적당한 비용 대비 효과

---

## 결론

각 RAG 기법은 고유한 장단점을 가지고 있으며, 사용 사례와 요구사항에 따라 적절한 기법을 선택하는 것이 중요합니다. 단순한 개선에서 시작하여 점진적으로 복잡한 기법을 도입하는 것을 권장합니다.

**💡 실무 활용 팁:**
- **단순한 QA**: Reranker 추가만으로도 효과적
- **복잡한 분석**: RAG Fusion + Reranker 조합
- **높은 신뢰성**: Self-RAG 또는 CRAG 적용
- **다양한 쿼리**: Adaptive RAG로 효율성 확보  
- **엔터프라이즈**: Agentic RAG로 복잡한 워크플로우 처리